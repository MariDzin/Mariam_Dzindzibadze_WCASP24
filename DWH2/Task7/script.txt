-- Creating necessary sequences
CREATE SEQUENCE IF NOT EXISTS BL_3NF.dealsize_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.payment_method_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.product_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.country_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.state_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.city_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.address_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.customer_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_3NF.ordernumber_seq;

-- checking every sequence if they exist and making sure they do exist


-- Creating a centralized logging table
CREATE TABLE IF NOT EXISTS procedure_logs (
    log_id SERIAL PRIMARY KEY,
    log_timestamp TIMESTAMPTZ DEFAULT NOW(),
    procedure_name TEXT,
    rows_affected INT,
    log_message TEXT
);

-- Creating a function for logging

CREATE OR REPLACE FUNCTION log_procedure_action(proc_name TEXT, rows INT, message TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO procedure_logs (procedure_name, rows_affected, log_message)
    VALUES (proc_name, rows, message);
END;
$$ LANGUAGE plpgsql;



--  creating function to load data into CE_DEALSIZES
CREATE OR REPLACE FUNCTION load_dealsizes()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            dealsize, dealsize AS dealsize_src_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order
        UNION ALL
        SELECT DISTINCT
            deal_size AS dealsize, deal_size AS dealsize_src_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order 
    LOOP
        BEGIN
            INSERT INTO BL_3NF.CE_DEALSIZES (DEALSIZE_ID, DEALSIZE, DEALSIZE_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.dealsize_id_seq'), rec.dealsize, rec.dealsize_src_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for dealsize %, skipping.', rec.dealsize;
        END;
    END LOOP;
    
    -- Loggin the action
    PERFORM log_procedure_action('load_dealsizes', rows_affected, 'Dealsizes loaded successfully');
END;
$$ LANGUAGE plpgsql;


-- creating function to load data into CE_PAYMENT_METHODS
CREATE OR REPLACE FUNCTION load_payment_methods()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            payment_method, payment_method AS payment_src_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order
        UNION ALL
        SELECT DISTINCT
            payment_method, payment_method AS payment_src_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order 
    LOOP
        BEGIN
            INSERT INTO BL_3NF.CE_PAYMENT_METHODS (PAYMENT_METHOD_ID, PAYMENT_METHOD, PAYMENT_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.payment_method_id_seq'), rec.payment_method, rec.payment_src_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for payment_method %, skipping.', rec.payment_method;
        END;
    END LOOP;
    
    
    PERFORM log_procedure_action('load_payment_methods', rows_affected, 'Payment methods loaded successfully');
END;
$$ LANGUAGE plpgsql;




-- function to load data into CE_PRODUCTS
CREATE OR REPLACE FUNCTION load_products()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            productcode, productline, priceeach::VARCHAR, msrp::VARCHAR, productcode AS product_src_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order
        UNION ALL
        SELECT DISTINCT
            product_model AS productcode, product_line AS productline, price_for_each AS priceeach, ms_rp AS msrp, product_model AS product_src_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order 
    LOOP
        BEGIN
            INSERT INTO BL_3NF.CE_PRODUCTS (PRODUCT_ID, PRODUCTCODE, PRODUCTLINE, PRICEEACH, MSRP, PRODUCT_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.product_id_seq'), rec.productcode, rec.productline, rec.priceeach::NUMERIC, rec.msrp::NUMERIC, rec.product_src_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for product %, skipping.', rec.productcode;
        END;
    END LOOP;
    
    -- Log the action
    PERFORM log_procedure_action('load_products', rows_affected, 'Products loaded successfully');
END;
$$ LANGUAGE plpgsql;






-- function to load data into CE_COUNTRIES
CREATE OR REPLACE FUNCTION load_countries()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            COALESCE(country, 'n. a.') AS country_name, COALESCE(country, 'n. a.') AS country_src_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order
        UNION ALL
        SELECT DISTINCT
            COALESCE(country_name, 'n. a.') AS country_name, COALESCE(country_name, 'n. a.') AS country_src_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order 
    LOOP
        BEGIN
            INSERT INTO BL_3NF.CE_COUNTRIES (COUNTRY_ID, COUNTRY_NAME, COUNTRY_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.country_id_seq'), rec.country_name, rec.country_src_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for country %, skipping.', rec.country_name;
        END;
    END LOOP;
    
    -- Log the action
    PERFORM log_procedure_action('load_countries', rows_affected, 'Countries loaded successfully');
END;
$$ LANGUAGE plpgsql;




-- function to load data into CE_STATES
CREATE OR REPLACE FUNCTION load_states()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            us.state AS state_name,
            COALESCE(us.state, 'n. a.') AS state_src_id, 
            COALESCE(c.country_id, -1) AS country_id,
            'sa_us_orders' AS source_system,
            'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_COUNTRIES c
        ON us.country = c.country_src_id
        AND c.source_system = 'sa_us_orders'
        AND c.source_entity = 'src_us_order'
    LOOP
        RAISE NOTICE 'Inserting state: %, Source: %, Source Entity: %', rec.state_name, rec.source_system, rec.source_entity;
        BEGIN
            INSERT INTO BL_3NF.CE_STATES (STATE_ID, STATE_NAME, STATE_SRC_ID, COUNTRY_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.state_id_seq'), rec.state_name, rec.state_src_id, rec.country_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for state %, skipping.', rec.state_name;
        END;
    END LOOP;
    
   
    PERFORM log_procedure_action('load_states', rows_affected, 'States loaded successfully');
END;
$$ LANGUAGE plpgsql;


-- function to load data into CE_STATES
CREATE OR REPLACE FUNCTION load_states()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            state AS state_name, COALESCE(state, 'n. a.') AS state_src_id, COALESCE(country_id, -1) AS country_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order
        LEFT JOIN BL_3NF.CE_COUNTRIES c
        ON us.country = c.country_src_id
        AND c.source_system = 'sa_us_orders'
        AND c.source_entity = 'src_us_order'
    LOOP
        BEGIN
            INSERT INTO BL_3NF.CE_STATES (STATE_ID, STATE_NAME, STATE_SRC_ID, COUNTRY_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.state_id_seq'), rec.state_name, rec.state_src_id, rec.country_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for state %, skipping.', rec.state_name;
        END;
    END LOOP;
    
    -- Log
    PERFORM log_procedure_action('load_states', rows_affected, 'States loaded successfully');
END;
$$ LANGUAGE plpgsql;

-- function to load data into CE_CITIES
CREATE OR REPLACE FUNCTION load_cities()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            us.city AS city_name,
            COALESCE(us.city, 'n. a.') AS city_src_id,
            COALESCE(s.state_id, -1) AS state_id,
            'sa_us_orders' AS source_system,
            'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_STATES s 
        ON us.state = s.state_name
        AND s.source_system = 'sa_us_orders'
        AND s.source_entity = 'src_us_order'
        UNION ALL
        SELECT DISTINCT
            nous.city_name AS city_name,
            COALESCE(nous.city_name, 'n. a.') AS city_src_id,
            -1 AS state_id, -- default value for state_id
            'sa_no_usa_orders' AS source_system,
            'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order nous
    LOOP
        RAISE NOTICE 'Inserting city: %, Source: %, Source Entity: %', rec.city_name, rec.source_system, rec.source_entity;
        BEGIN
            INSERT INTO BL_3NF.CE_CITIES (CITY_ID, CITY_NAME, CITY_SRC_ID, STATE_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.city_id_seq'), rec.city_name, rec.city_src_id, rec.state_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for city %, skipping.', rec.city_name;
        END;
    END LOOP;
    
    -- Log
    PERFORM log_procedure_action('load_cities', rows_affected, 'Cities loaded successfully');
END;
$$ LANGUAGE plpgsql;




-- function to load data into CE_ADDRESSES
CREATE OR REPLACE FUNCTION load_addresses()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            COALESCE(us.addressline1, 'n. a.') AS addressline1, 
            COALESCE(us.address_id::VARCHAR, 'n. a.') AS address_src_id,
            COALESCE(c.city_id, -1) AS city_id, 
            'sa_us_orders' AS source_system, 
            'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_CITIES c 
        ON us.city = c.city_name
        AND c.source_system = 'sa_us_orders'
        AND c.source_entity = 'src_us_order'
        UNION ALL
        SELECT DISTINCT
            COALESCE(nous.address_line, 'n. a.') AS addressline1,
            COALESCE(nous.address_id_num::VARCHAR, 'n. a.') AS address_src_id,
            COALESCE(c.city_id, -1) AS city_id,
            'sa_no_usa_orders' AS source_system,
            'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order nous
        LEFT JOIN BL_3NF.CE_CITIES c 
        ON nous.city_name = c.city_name
        AND c.source_system = 'sa_no_usa_orders'
        AND c.source_entity = 'src_no_usa_order'
    LOOP
        RAISE NOTICE 'Inserting address: %, Source: %, Source Entity: %', rec.addressline1, rec.source_system, rec.source_entity;
        BEGIN
            INSERT INTO BL_3NF.CE_ADDRESSES (ADDRESS_ID, ADDRESSLINE1, ADDRESS_SRC_ID, CITY_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.address_id_seq'), rec.addressline1, rec.address_src_id, rec.city_id, CURRENT_DATE, CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for address %, skipping.', rec.addressline1;
        END;
    END LOOP;
    
    -- Log     PERFORM log_procedure_action('load_addresses', rows_affected, 'Addresses loaded successfully');
END;
$$ LANGUAGE plpgsql;

-- function to load data into CE_CUSTOMERS_SCD
CREATE OR REPLACE FUNCTION load_customers()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            COALESCE(us.customer_id::BIGINT, -1) AS customer_id, 
            COALESCE(us.customername, 'n. a.') AS customername,
            COALESCE(us.contactfirstname, 'n. a.') AS contactfirstname,
            COALESCE(us.contactlastname, 'n. a.') AS contactlastname,
            COALESCE(us.phone, 'n. a.') AS phone,
            COALESCE(us.customer_id::VARCHAR, 'n. a.') AS customer_src_id,
            COALESCE(a.address_id, -1) AS address_id,
            'sa_us_orders' AS source_system,
            'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_ADDRESSES a 
        ON us.addressline1 = a.addressline1
        AND a.source_system = 'sa_us_orders'
        AND a.source_entity = 'src_us_order'
        UNION ALL
        SELECT DISTINCT
            COALESCE(nous.customers_id::BIGINT, -1) AS customer_id, 
            COALESCE(nous.cust_name, 'n. a.') AS customername,
            COALESCE(nous.cust_firstname, 'n. a.') AS contactfirstname,
            COALESCE(nous.cust_lastname, 'n. a.') AS contactlastname,
            COALESCE(nous.phone_number, 'n. a.') AS phone,
            COALESCE(nous.customers_id::VARCHAR, 'n. a.') AS customer_src_id,
            COALESCE(a.address_id, -1) AS address_id,
            'sa_no_usa_orders' AS source_system,
            'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order nous
        LEFT JOIN BL_3NF.CE_ADDRESSES a 
        ON nous.address_line = a.addressline1
        AND a.source_system = 'sa_no_usa_orders'
        AND a.source_entity = 'src_no_usa_order'
    LOOP
        RAISE NOTICE 'Inserting customer: %, Source: %, Source Entity: %', rec.customername, rec.source_system, rec.source_entity;
        BEGIN
            INSERT INTO BL_3NF.CE_CUSTOMERS_SCD (CUSTOMER_ID, CUSTOMERNAME, CONTACTFIRSTNAME, CONTACTLASTNAME, PHONE, CUSTOMER_SRC_ID, ADDRESS_ID, START_DT, END_DT, IS_ACTIVE, TA_INSERT_DT, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (nextval('BL_3NF.customer_id_seq'), rec.customername, rec.contactfirstname, rec.contactlastname, rec.phone, rec.customer_src_id, rec.address_id, CURRENT_DATE, '9999-12-31', 'Y', CURRENT_DATE, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for customer %, skipping.', rec.customername;
        END;
    END LOOP;
    
    -- log
    PERFORM log_procedure_action('load_customers', rows_affected, 'Customers loaded successfully');
END;
$$ LANGUAGE plpgsql;



-- function to load data into CE_ORDERS
CREATE OR REPLACE FUNCTION load_orders()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    rows_affected INT := 0;
BEGIN
    FOR rec IN 
        SELECT DISTINCT
            us.ordernumber::BIGINT AS ordernumber,  
            us.quantityordered::INTEGER AS quantityordered,  
            us.sales::NUMERIC AS sales,  
            pm.PAYMENT_METHOD_ID AS payment_method_id,
            ds.DEALSIZE_ID AS dealsize_id,
            p.PRODUCT_ID AS product_id,
            c.CUSTOMER_ID AS customer_id,
            us.orderdate::DATE AS event_dt,  
            'sa_us_orders' AS source_system,
            'src_us_order' AS source_entity,
            us.ordernumber::VARCHAR AS order_src_id
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_PAYMENT_METHODS pm 
        ON us.payment_method = pm.payment_method
        AND pm.source_system = 'sa_us_orders'
        AND pm.source_entity = 'src_us_order'
        LEFT JOIN BL_3NF.CE_DEALSIZES ds 
        ON us.dealsize = ds.dealsize
        AND ds.source_system = 'sa_us_orders'
        AND ds.source_entity = 'src_us_order'
        LEFT JOIN BL_3NF.CE_PRODUCTS p 
        ON us.productcode = p.productcode
        AND p.source_system = 'sa_us_orders'
        AND p.source_entity = 'src_us_order'
        LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
        ON us.customer_id::BIGINT = c.customer_id
        AND c.source_system = 'sa_us_orders'
        AND c.source_entity = 'src_us_order'
        UNION ALL
        SELECT DISTINCT
            nous.order_id::BIGINT AS ordernumber,  
            nous.quantity::INTEGER AS quantityordered,  
            nous.sales_amount::NUMERIC AS sales,  
            pm.PAYMENT_METHOD_ID AS payment_method_id,
            ds.DEALSIZE_ID AS dealsize_id,
            p.PRODUCT_ID AS product_id,
            c.CUSTOMER_ID AS customer_id,
            nous.date_of_order::DATE AS event_dt, 
            'sa_no_usa_orders' AS source_system,
            'src_no_usa_order' AS source_entity,
            nous.order_id::VARCHAR AS order_src_id
        FROM sa_no_usa_orders.src_no_usa_order nous
        LEFT JOIN BL_3NF.CE_PAYMENT_METHODS pm 
        ON nous.payment_method = pm.payment_method
        AND pm.source_system = 'sa_no_usa_orders'
        AND pm.source_entity = 'src_no_usa_order'
        LEFT JOIN BL_3NF.CE_DEALSIZES ds 
        ON nous.deal_size = ds.dealsize
        AND ds.source_system = 'sa_no_usa_orders'
        AND ds.source_entity = 'src_no_usa_order'
        LEFT JOIN BL_3NF.CE_PRODUCTS p 
        ON nous.product_model = p.productcode
        AND p.source_system = 'sa_no_usa_orders'
        AND p.source_entity = 'src_no_usa_order'
        LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
        ON nous.customers_id::BIGINT = c.customer_id
        AND c.source_system = 'sa_no_usa_orders'
        AND c.source_entity = 'src_no_usa_order'
    LOOP
        -- checking for NULL values in mandatory fields
        IF rec.payment_method_id IS NULL OR rec.dealsize_id IS NULL OR rec.product_id IS NULL OR rec.customer_id IS NULL THEN
            RAISE NOTICE 'Skipping order % due to NULL values in mandatory fields.', rec.ordernumber;
            CONTINUE;
        END IF;

        RAISE NOTICE 'Inserting order: %, Source: %, Source Entity: %', rec.ordernumber, rec.source_system, rec.source_entity;
        BEGIN
            INSERT INTO BL_3NF.CE_ORDERS (ORDERNUMBER, QUANTITYORDERED, SALES, PAYMENT_METHOD_ID, DEALSIZE_ID, PRODUCT_ID, CUSTOMER_ID, EVENT_DT, TA_INSERT_DT, TA_UPDATE_DT, ORDER_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY)
            VALUES (COALESCE(rec.ordernumber, nextval('BL_3NF.ordernumber_seq')), rec.quantityordered, rec.sales, rec.payment_method_id, rec.dealsize_id, rec.product_id, rec.customer_id, rec.event_dt, CURRENT_DATE, CURRENT_DATE, rec.order_src_id, rec.source_system, rec.source_entity);
            rows_affected := rows_affected + 1;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE NOTICE 'Duplicate entry for order %, skipping.', rec.ordernumber;
        END;
    END LOOP;
    
    -- Logging the action
    PERFORM log_procedure_action('load_orders', rows_affected, 'Orders loaded successfully');
END;
$$ LANGUAGE plpgsql;



SELECT load_dealsizes();
SELECT load_payment_methods();
SELECT load_products();
SELECT load_countries();
SELECT load_states();
SELECT load_cities();
SELECT load_addresses();
SELECT load_customers();
SELECT load_orders();

SELECT * FROM procedure_logs;



SELECT * FROM BL_3NF.CE_DEALSIZES;
SELECT * FROM BL_3NF.CE_PAYMENT_METHODS;
SELECT * FROM BL_3NF.CE_PRODUCTS;
SELECT * FROM BL_3NF.CE_COUNTRIES;
SELECT * FROM BL_3NF.CE_STATES;
SELECT * FROM BL_3NF.CE_CITIES;
SELECT * FROM BL_3NF.CE_ADDRESSES;
SELECT * FROM BL_3NF.CE_CUSTOMERS_SCD;
SELECT * FROM BL_3NF.CE_ORDERS;


