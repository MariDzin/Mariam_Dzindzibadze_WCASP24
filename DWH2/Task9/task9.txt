-- Drop the table if it already exists to start fresh
DROP TABLE IF EXISTS BL_DM.fct_orders CASCADE;


-- Create the logging table:

CREATE TABLE IF NOT EXISTS BL_3NF.procedure_logs (
    id SERIAL PRIMARY KEY,
    procedure_name TEXT,
    rows_affected INT,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    message TEXT
);

-- define the logging function:
CREATE OR REPLACE FUNCTION BL_3NF.log_procedure_action(procedure_name TEXT, rows_affected INT, message TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO BL_3NF.procedure_logs (procedure_name, rows_affected, message)
    VALUES (procedure_name, rows_affected, message);
END;
$$ LANGUAGE plpgsql;


-- Create the main fact table as partitioned
CREATE TABLE if not exists BL_DM.fct_orders (
    ordernumber BIGINT,
    payment_method_surr_id INT,
    dealsize_surr_id INT,
    product_surr_id INT,
    customer_surr_id INT,
    date_id BIGINT,
    sales NUMERIC,
    quantityordered INT,
    total_cost NUMERIC,
    ta_insert_dt TIMESTAMP,
    ta_update_dt TIMESTAMP,
    event_dt DATE,
    source_system TEXT,
    source_entity TEXT
) PARTITION BY RANGE (event_dt);


-- Partitions for the years 2003, 2004, 2005
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2003 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2003-01-01') TO ('2004-01-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2004 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2004-01-01') TO ('2005-01-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-01-01') TO ('2006-01-01');
   
   

   
-- procedure
-- Create the procedure to handle data load with dynamic partitions
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_fact_table()
LANGUAGE plpgsql
AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    current_partition_name TEXT;
    temp_partition_name TEXT;
    rows_affected INT := 0;
BEGIN
    -- Define the rolling window period
    start_date := CURRENT_DATE - INTERVAL '3 months';
    end_date := CURRENT_DATE;

    -- Create partition for current rolling window
    current_partition_name := 'fct_orders_' || TO_CHAR(start_date, 'YYYYMMDD') || '_to_' || TO_CHAR(end_date, 'YYYYMMDD');
    temp_partition_name := 'temp_' || current_partition_name;

    EXECUTE 'CREATE TABLE IF NOT EXISTS BL_DM.' || current_partition_name || ' PARTITION OF BL_DM.fct_orders FOR VALUES FROM (''' || start_date || ''') TO (''' || end_date || ''');';

    -- Create a temporary table to hold new records
    EXECUTE 'CREATE TEMP TABLE ' || temp_partition_name || ' AS SELECT DISTINCT * FROM BL_DM.fct_orders WHERE 1=0;';

    -- Load data into the temporary table
    EXECUTE 'INSERT INTO ' || temp_partition_name || ' SELECT DISTINCT o.ordernumber, o.payment_method_id, o.dealsize_id, o.product_id, o.customer_id, 
				TO_CHAR(o.event_dt::DATE, ''DDMMYYYY'')::BIGINT, o.sales, o.quantityordered, (o.sales * o.quantityordered), o.ta_insert_dt, CURRENT_TIMESTAMP, 
o.event_dt, o.source_system, o.source_entity FROM BL_3NF.CE_ORDERS o WHERE o.event_dt BETWEEN ''' || start_date || ''' AND ''' || end_date || ''' AND EXISTS 
(SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = TO_CHAR(o.event_dt::DATE, ''DDMMYYYY'')::BIGINT) AND EXISTS (SELECT 1 FROM BL_DM.dim_customers c WHERE c.customer_surr_id = o.customer_id) AND EXISTS 
(SELECT 1 FROM BL_DM.dim_payment_methods pm WHERE pm.payment_method_surr_id = o.payment_method_id) AND EXISTS (SELECT 1 FROM BL_DM.dim_dealsizes ds WHERE ds.dealsize_surr_id = o.dealsize_id) AND EXISTS (SELECT 1 FROM BL_DM.dim_products p WHERE p.product_surr_id = o.product_id);';

    -- Insert new records from the temporary table
    EXECUTE 'INSERT INTO BL_DM.' || current_partition_name || ' SELECT * FROM ' || temp_partition_name || ' t WHERE NOT EXISTS (SELECT 1 FROM BL_DM.fct_orders f WHERE f.ordernumber = t.ordernumber);';

    -- Update existing records from the temporary table
    EXECUTE 'UPDATE BL_DM.fct_orders f SET payment_method_surr_id = t.payment_method_surr_id, dealsize_surr_id = t.dealsize_surr_id, product_surr_id = t.product_surr_id, customer_surr_id = t.customer_surr_id, date_id = t.date_id, sales = t.sales, 
quantityordered = t.quantityordered, total_cost = t.total_cost, ta_update_dt = t.ta_update_dt, event_dt = t.event_dt, source_system = t.source_system, source_entity = t.source_entity FROM ' || temp_partition_name || ' t WHERE f.ordernumber = t.ordernumber;';

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_fact_table', rows_affected, 'Orders loaded successfully into DM. Rows affected: ' || rows_affected);

    -- Drop the temporary table
    EXECUTE 'DROP TABLE ' || temp_partition_name;


END;
$$;



CALL BL_DM.load_dm_fact_table();

select * from BL_DM.fct_orders fo 


SELECT * FROM BL_3NF.procedure_logs WHERE procedure_name = 'load_dm_fact_table' ORDER BY log_time DESC;




-- Check for duplicates in the fact table by counting occurrences of each ordernumber
SELECT ordernumber, COUNT(*)
FROM BL_DM.fct_orders
GROUP BY ordernumber
HAVING COUNT(*) > 1;

-- Verify that all business keys  from the source table are loaded into the destination table
SELECT ordernumber
FROM BL_3NF.CE_ORDERS
EXCEPT
SELECT ordernumber
FROM BL_DM.fct_orders;

-- Count the number of records in the source table for the last 3 months
SELECT COUNT(*) 
FROM BL_3NF.CE_ORDERS 
WHERE event_dt BETWEEN CURRENT_DATE - INTERVAL '3 months' AND CURRENT_DATE;

-- Get the minimum and maximum event_dt from the source table to understand the date range of the data

SELECT MIN(event_dt), MAX(event_dt) 
FROM BL_3NF.CE_ORDERS;


-- Count the number of records in the source table for the year 2003

SELECT COUNT(*) 
FROM BL_3NF.CE_ORDERS 
WHERE event_dt BETWEEN '2003-01-01' AND '2003-12-31';






