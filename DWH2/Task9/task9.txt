-- Drop the table if it already exists to start fresh
DROP TABLE IF EXISTS BL_DM.fct_orders CASCADE;

-- Create the logging table in the BL_CL schema:
CREATE TABLE IF NOT EXISTS BL_CL.procedure_logs (
    id SERIAL PRIMARY KEY,
    procedure_name TEXT,
    rows_affected INT,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    message TEXT
);


SELECT * 
FROM information_schema.tables 
WHERE table_schema = 'bl_3nf' 
AND table_name = 'src_orders';


-- creating table

CREATE table if not exists bl_3nf.src_orders (
    ordernumber BIGINT PRIMARY KEY,
    orderdate DATE,
    customer_id BIGINT,
    product_id BIGINT,
    dealsize_id BIGINT,
    payment_method_id BIGINT,
    event_dt date,
    sales NUMERIC,
    quantityordered INT,
    source_system TEXT,
    source_entity TEXT
);
SELECT 
    o.ordernumber,
    o.payment_method_id,
    o.dealsize_id,
    o.product_id,
    o.customer_id,
    o.event_dt, 
    o.sales,
    o.quantityordered,
    o.ta_insert_dt,
    o.ta_update_dt,
    o.source_system,
    o.source_entity
FROM bl_3nf.ce_orders o 



-- Define the logging function in the BL_CL schema:
CREATE OR REPLACE FUNCTION BL_CL.log_procedure_action(procedure_name TEXT, rows_affected INT, message TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO BL_CL.procedure_logs (procedure_name, rows_affected, message)
    VALUES (procedure_name, rows_affected, message);
END;
$$ LANGUAGE plpgsql;

-- Create the main fact table as partitioned
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders (
    ordernumber BIGINT,
    payment_method_surr_id INT,
    dealsize_surr_id INT,
    product_surr_id INT,
    customer_surr_id INT,
    date_id BIGINT,
    sales NUMERIC,
    quantityordered INT,
    total_cost NUMERIC,
    ta_insert_dt TIMESTAMP,
    ta_update_dt TIMESTAMP,
    event_dt DATE,
    source_system TEXT,
    source_entity TEXT,
    CONSTRAINT fk_payment_method FOREIGN KEY (payment_method_surr_id) REFERENCES BL_DM.dim_payment_methods(payment_method_surr_id),
    CONSTRAINT fk_dealsize FOREIGN KEY (dealsize_surr_id) REFERENCES BL_DM.dim_dealsizes(dealsize_surr_id),
    CONSTRAINT fk_product FOREIGN KEY (product_surr_id) REFERENCES BL_DM.dim_products(product_surr_id),
    CONSTRAINT fk_customer FOREIGN KEY (customer_surr_id) REFERENCES BL_DM.dim_customers(customer_surr_id),
    CONSTRAINT fk_date FOREIGN KEY (date_id) REFERENCES BL_DM.dim_dates(date_id)
) PARTITION BY RANGE (event_dt);

-- Partitions for the years 2003, 2004, 2005
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2003 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2003-01-01') TO ('2004-01-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2004 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2004-01-01') TO ('2005-01-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-01-01') TO ('2006-01-01');

-- Updated procedure with explicit type casts
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_fact_table()
LANGUAGE plpgsql
AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    current_partition_name TEXT;
    temp_partition_name TEXT;
    rows_affected INT := 0;
BEGIN
    -- Define the rolling window period
    start_date := CURRENT_DATE - INTERVAL '3 months';
    end_date := CURRENT_DATE;

    -- Create partition for current rolling window
    current_partition_name := 'fct_orders_' || TO_CHAR(start_date, 'YYYYMMDD') || '_to_' || TO_CHAR(end_date, 'YYYYMMDD');
    temp_partition_name := 'temp_' || current_partition_name;

    EXECUTE 'CREATE TABLE IF NOT EXISTS BL_DM.' || current_partition_name || ' PARTITION OF BL_DM.fct_orders FOR VALUES FROM (''' || start_date || ''') TO (''' || end_date || ''');';

    -- Create a temporary table to hold new records
    EXECUTE 'CREATE TEMP TABLE ' || temp_partition_name || ' AS SELECT DISTINCT * FROM BL_DM.fct_orders WHERE 1=0;';

    -- Load data into the temporary table
    EXECUTE 'INSERT INTO ' || temp_partition_name || ' SELECT DISTINCT o.ordernumber, o.payment_method_id, o.dealsize_id, o.product_id, o.customer_id, 
				TO_CHAR(o.event_dt::DATE, ''DDMMYYYY'')::BIGINT, o.sales, o.quantityordered, (o.sales * o.quantityordered), o.ta_insert_dt, CURRENT_TIMESTAMP, 
o.event_dt, o.source_system, o.source_entity FROM BL_3NF.CE_ORDERS o WHERE o.event_dt BETWEEN ''' || start_date || ''' AND ''' || end_date || ''' AND EXISTS 
(SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = TO_CHAR(o.event_dt::DATE, ''DDMMYYYY'')::BIGINT) AND EXISTS (SELECT 1 FROM BL_DM.dim_customers c WHERE c.customer_surr_id = o.customer_id) AND EXISTS 
(SELECT 1 FROM BL_DM.dim_payment_methods pm WHERE pm.payment_method_surr_id = o.payment_method_id) AND EXISTS (SELECT 1 FROM BL_DM.dim_dealsizes ds WHERE ds.dealsize_surr_id = o.dealsize_id) AND EXISTS (SELECT 1 FROM BL_DM.dim_products p WHERE p.product_surr_id = o.product_id);';

    -- Insert new records from the temporary table
    EXECUTE 'INSERT INTO BL_DM.' || current_partition_name || ' SELECT * FROM ' || temp_partition_name || ' t WHERE NOT EXISTS (SELECT 1 FROM BL_DM.fct_orders f WHERE f.ordernumber = t.ordernumber);';

    -- Update existing records from the temporary table
    EXECUTE 'UPDATE BL_DM.fct_orders f SET payment_method_surr_id = t.payment_method_surr_id, dealsize_surr_id = t.dealsize_surr_id, product_surr_id = t.product_surr_id, customer_surr_id = t.customer_surr_id, date_id = t.date_id, sales = t.sales, 
quantityordered = t.quantityordered, total_cost = t.total_cost, ta_update_dt = t.ta_update_dt, event_dt = t.event_dt, source_system = t.source_system, source_entity = t.source_entity FROM ' || temp_partition_name || ' t WHERE f.ordernumber = t.ordernumber;';

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action with explicit type casting
    PERFORM BL_CL.log_procedure_action('load_dm_fact_table'::TEXT, rows_affected::INT, 'Orders loaded successfully into DM. Rows affected: ' || rows_affected::TEXT);

    -- Drop the temporary table
    EXECUTE 'DROP TABLE ' || temp_partition_name;

END;
$$;


CREATE OR REPLACE PROCEDURE BL_3NF.load_3nf_fact_table_incrementally()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into the CE_ORDERS table incrementally
    INSERT INTO BL_3NF.CE_ORDERS (ordernumber, payment_method_id, dealsize_id, product_id, customer_id, event_dt, sales, quantityordered, ta_insert_dt, ta_update_dt, source_system, source_entity)
    SELECT DISTINCT
        ordernumber,
        payment_method_id,
        dealsize_id,
        product_id,
        customer_id,
        event_dt,  
        sales,
        quantityordered,
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        source_system,
        source_entity
    FROM BL_3NF.src_orders
    WHERE NOT EXISTS (
        SELECT 1 FROM BL_3NF.CE_ORDERS o
        WHERE o.ordernumber = BL_3NF.src_orders.ordernumber
    );

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_CL.log_procedure_action('load_3nf_fact_table_incrementally', rows_affected, 'Orders loaded successfully into 3NF fact table. Rows affected: ' || rows_affected);
END;
$$;


-- Example of running the procedures
CALL BL_DM.load_dm_fact_table();
CALL BL_3NF.load_3nf_fact_table_incrementally();

-- Example of querying the fact table
SELECT * FROM BL_DM.fct_orders LIMIT 10;

-- Example of querying the procedure logs
SELECT * FROM BL_CL.procedure_logs ORDER BY log_timestamp DESC;


-- Check for duplicates in the fact table by counting occurrences of each ordernumber
SELECT ordernumber, COUNT(*)
FROM BL_DM.fct_orders
GROUP BY ordernumber
HAVING COUNT(*) > 1;

-- Verify that all business keys from the source table are loaded into the destination table
SELECT ordernumber
FROM BL_3NF.CE_ORDERS
EXCEPT
SELECT ordernumber
FROM BL_DM.fct_orders;

-- Count the number of records in the source table for the last 3 months based on the maximum date in the table
SELECT COUNT(*) 
FROM BL_3NF.CE_ORDERS 
WHERE event_dt BETWEEN (SELECT MAX(event_dt) FROM BL_3NF.CE_ORDERS) - INTERVAL '3 months' 
AND (SELECT MAX(event_dt) FROM BL_3NF.CE_ORDERS);


-- Get the minimum and maximum event_dt from the source table to understand the date range of the data
SELECT MIN(event_dt), MAX(event_dt) 
FROM BL_3NF.CE_ORDERS;

-- Count the number of records in the source table for the year 2003
SELECT COUNT(*) 
FROM BL_3NF.CE_ORDERS 
WHERE event_dt BETWEEN '2003-01-01' AND '2003-12-31';








