CREATE SCHEMA IF NOT EXISTS sa_no_usa_orders;
CREATE SCHEMA IF NOT EXISTS sa_us_orders;
CREATE EXTENSION IF NOT EXISTS file_fdw;  


    -- Drop Foreign Tables if they exist
    DROP FOREIGN TABLE IF EXISTS sa_no_usa_orders.ext_no_usa_order;
    DROP FOREIGN TABLE IF  EXISTS sa_us_orders.ext_us_order;



    -- Create Foreign Table for Non-USA Orders
    CREATE FOREIGN TABLE IF NOT EXISTS sa_no_usa_orders.ext_no_usa_order (
        order_id VARCHAR(150),
        quantity VARCHAR(150),
        price_for_each VARCHAR(150),
        sales_amount VARCHAR(150),
        date_of_order VARCHAR(150),
        deal_size VARCHAR(150),
        quarter VARCHAR(150),
        day VARCHAR(150),
        month VARCHAR(150),
        year VARCHAR(150),
        productline_id VARCHAR(150),
        product_line VARCHAR(150),
        ms_rp VARCHAR(150),
        product_model VARCHAR(150),
        customers_id VARCHAR(150),
        cust_name VARCHAR(150),
        cust_firstname VARCHAR(150),
        cust_lastname VARCHAR(150),
        phone_number VARCHAR(150),
        address_id_num VARCHAR(150),
        address_line VARCHAR(150),
        city_name VARCHAR(150),
        postcode VARCHAR(150),
        country_name VARCHAR(150),
        payment_method VARCHAR(150)
    ) SERVER file_server 
    OPTIONS (
        filename 'C:\\Program Files\\PostgreSQL\\16\\data\\updated_csvfile_no_usa.csv',
        format 'csv',
        header 'true',
        delimiter ',',
        quote '"',
        escape E'\\', 
        null 'NULL',
        encoding 'UTF8'
    );

    -- Create Foreign Table for USA Orders
    CREATE FOREIGN TABLE IF NOT EXISTS sa_us_orders.ext_us_order (
        ordernumber VARCHAR(150),
        quantityordered VARCHAR(150),
        priceeach VARCHAR(150),
        sales VARCHAR(150),
        orderdate VARCHAR(150),
        dealsize VARCHAR(150),
        qtr_id VARCHAR(150),
        day_id VARCHAR(150),
        month_id VARCHAR(150),
        year_id VARCHAR(150),
        productline_id VARCHAR(150),
        productline VARCHAR(150),
        msrp VARCHAR(150),
        productcode VARCHAR(150),
        customer_id VARCHAR(150),
        customername VARCHAR(150),
        contactfirstname VARCHAR(150),
        contactlastname VARCHAR(150),
        phone VARCHAR(150),
        address_id VARCHAR(150),
        addressline1 VARCHAR(150),
        city VARCHAR(150),
        state VARCHAR(150),
        postalcode VARCHAR(150),
        country VARCHAR(150),
        payment_method VARCHAR(150)
    ) SERVER file_server 
    OPTIONS (
        filename 'C:\\Program Files\\PostgreSQL\\16\\data\\jeff.csv',
        format 'csv',
        header 'true',
        delimiter ',',
        quote '"',
        escape E'\\', 
        null 'NULL',
        encoding 'UTF8'
    );





--  Procedure for Creating Source Tables


CREATE OR REPLACE PROCEDURE public.create_src_tables_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Create source table for non-USA orders
    CREATE TABLE IF NOT EXISTS sa_no_usa_orders.src_no_usa_order (
        order_id VARCHAR(150),
        quantity VARCHAR(150),
        price_for_each VARCHAR(150),
        sales_amount VARCHAR(150),
        date_of_order VARCHAR(150),
        deal_size VARCHAR(150),
        quarter VARCHAR(150),
        day VARCHAR(150),
        month VARCHAR(150),
        year VARCHAR(150),
        productline_id VARCHAR(150),
        product_line VARCHAR(150),
        ms_rp VARCHAR(150),
        product_model VARCHAR(150),
        customers_id VARCHAR(150),
        cust_name VARCHAR(150),
        cust_firstname VARCHAR(150),
        cust_lastname VARCHAR(150),
        phone_number VARCHAR(150),
        address_id_num VARCHAR(150),
        address_line VARCHAR(150),
        city_name VARCHAR(150),
        postcode VARCHAR(150),
        country_name VARCHAR(150),
        payment_method VARCHAR(150)
    );

    -- Create source table for USA orders
    CREATE TABLE IF NOT EXISTS sa_us_orders.src_us_order (
        ordernumber VARCHAR(150),
        quantityordered VARCHAR(150),
        priceeach VARCHAR(150),
        sales VARCHAR(150),
        orderdate VARCHAR(150),
        dealsize VARCHAR(150),
        qtr_id VARCHAR(150),
        day_id VARCHAR(150),
        month_id VARCHAR(150),
        year_id VARCHAR(150),
        productline_id VARCHAR(150),
        productline VARCHAR(150),
        msrp VARCHAR(150),
        productcode VARCHAR(150),
        customer_id VARCHAR(150),
        customername VARCHAR(150),
        contactfirstname VARCHAR(150),
        contactlastname VARCHAR(150),
        phone VARCHAR(150),
        address_id VARCHAR(150),
        addressline1 VARCHAR(150),
        city VARCHAR(150),
        state VARCHAR(150),
        postalcode VARCHAR(150),
        country VARCHAR(150),
        payment_method VARCHAR(150)
    );

    RAISE NOTICE 'Source tables created';
    
EXCEPTION
    WHEN OTHERS THEN
        -- Raise the exception to propagate the error
        RAISE NOTICE 'Source tables are not created: %', SQLERRM;
END;
$$;

-- Call the procedure to create source tables
CALL public.create_src_tables_procedure();



-- Create Logging Table
CREATE TABLE IF NOT EXISTS public.logging (
    log_id SERIAL PRIMARY KEY,
    log_datetime TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    procedure_name VARCHAR(255),
    rows_affected INT,
    message TEXT
);



-- Procedure for Non-USA Orders
CREATE OR REPLACE PROCEDURE sa_no_usa_orders.insert_data_into_src_no_usa_procedure()
LANGUAGE plpgsql
AS $$
DECLARE 
    inserted_count INTEGER;
BEGIN
    WITH inserted AS (
        INSERT INTO sa_no_usa_orders.src_no_usa_order (
            order_id, quantity, price_for_each, sales_amount, date_of_order, 
            deal_size, quarter, day, month, year, productline_id, product_line, 
            ms_rp, product_model, customers_id, cust_name, cust_firstname, 
            cust_lastname, phone_number, address_id_num, address_line, 
            city_name, postcode, country_name, payment_method
        )
        SELECT DISTINCT
            nous.order_id::VARCHAR(150),
            nous.quantity::VARCHAR(150),
            nous.price_for_each::VARCHAR(150),
            nous.sales_amount::VARCHAR(150),
            nous.date_of_order::VARCHAR(150),
            nous.deal_size::VARCHAR(150),
            nous.quarter::VARCHAR(150),
            nous.day::VARCHAR(150),
            nous.month::VARCHAR(150),
            nous.year::VARCHAR(150),
            nous.productline_id::VARCHAR(150),
            nous.product_line::VARCHAR(150),
            nous.ms_rp::VARCHAR(150),
            nous.product_model::VARCHAR(150),
            nous.customers_id::VARCHAR(150),
            nous.cust_name::VARCHAR(150),
            nous.cust_firstname::VARCHAR(150),
            nous.cust_lastname::VARCHAR(150),
            nous.phone_number::VARCHAR(150),
            nous.address_id_num::VARCHAR(150),
            nous.address_line::VARCHAR(150),
            nous.city_name::VARCHAR(150),
            nous.postcode::VARCHAR(150),
            nous.country_name::VARCHAR(150),
            nous.payment_method::VARCHAR(150)
        FROM sa_no_usa_orders.ext_no_usa_order nous
        WHERE NOT EXISTS (
            SELECT 1 
            FROM sa_no_usa_orders.src_no_usa_order src
            WHERE src.order_id = nous.order_id
        )
        RETURNING 1
    )
    SELECT COUNT(*) INTO inserted_count FROM inserted;
    
    -- Log the operation
    INSERT INTO public.logging (procedure_name, rows_affected, message)
    VALUES ('insert_data_into_src_no_usa_procedure', inserted_count, 'Inserted new data into src_no_usa_order table');

    RAISE NOTICE 'Inserted rows into src_no_usa_order: %', inserted_count;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO public.logging (procedure_name, rows_affected, message)
        VALUES ('insert_data_into_src_no_usa_procedure', 0, 'Error occurred: ' || SQLERRM);
        RAISE NOTICE 'Error occurred while inserting data into src_no_usa_order: %', SQLERRM;
END;
$$;

-- Procedure for USA Orders
CREATE OR REPLACE PROCEDURE sa_us_orders.insert_data_into_src_us_procedure()
LANGUAGE plpgsql
AS $$
DECLARE 
    inserted_count INTEGER;
BEGIN
    WITH inserted AS (
        INSERT INTO sa_us_orders.src_us_order (
            ordernumber, quantityordered, priceeach, sales, orderdate, dealsize, 
            qtr_id, day_id, month_id, year_id, productline_id, productline, 
            msrp, productcode, customer_id, customername, contactfirstname, 
            contactlastname, phone, address_id, addressline1, city, state, 
            postalcode, country, payment_method
        )
        SELECT DISTINCT
            us.ordernumber::VARCHAR(150),
            us.quantityordered::VARCHAR(150),
            us.priceeach::VARCHAR(150),
            us.sales::VARCHAR(150),
            us.orderdate::VARCHAR(150),
            us.dealsize::VARCHAR(150),
            us.qtr_id::VARCHAR(150),
            us.day_id::VARCHAR(150),
            us.month_id::VARCHAR(150),
            us.year_id::VARCHAR(150),
            us.productline_id::VARCHAR(150),
            us.productline::VARCHAR(150),
            us.msrp::VARCHAR(150),
            us.productcode::VARCHAR(150),
            us.customer_id::VARCHAR(150),
            us.customername::VARCHAR(150),
            us.contactfirstname::VARCHAR(150),
            us.contactlastname::VARCHAR(150),
            us.phone::VARCHAR(150),
            us.address_id::VARCHAR(150),
            us.addressline1::VARCHAR(150),
            us.city::VARCHAR(150),
            us.state::VARCHAR(150),
            us.postalcode::VARCHAR(150),
            us.country::VARCHAR(150),
            us.payment_method::VARCHAR(150)
        FROM sa_us_orders.ext_us_order us
        WHERE NOT EXISTS (
            SELECT 1 
            FROM sa_us_orders.src_us_order src
            WHERE src.ordernumber = us.ordernumber
        )
        RETURNING 1
    )
    SELECT COUNT(*) INTO inserted_count FROM inserted;
    
    -- Log the operation
    INSERT INTO public.logging (procedure_name, rows_affected, message)
    VALUES ('insert_data_into_src_us_procedure', inserted_count, 'Inserted new data into src_us_order table');

    RAISE NOTICE 'Inserted rows into src_us_order: %', inserted_count;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO public.logging (procedure_name, rows_affected, message)
        VALUES ('insert_data_into_src_us_procedure', 0, 'Error occurred: ' || SQLERRM);
        RAISE NOTICE 'Error occurred while inserting data into src_us_order: %', SQLERRM;
END;
$$;


-- Create Indexes for Efficient Lookup
CREATE INDEX IF NOT EXISTS order_id_index_no_usa 
    ON sa_no_usa_orders.src_no_usa_order(order_id);

CREATE INDEX IF NOT EXISTS ordernumber_index_us 
    ON sa_us_orders.src_us_order(ordernumber);

-- Call the Procedures to Insert Data
CALL sa_no_usa_orders.insert_data_into_src_no_usa_procedure();
CALL sa_us_orders.insert_data_into_src_us_procedure();


-- Step 11: Verify the Data Insertion
SELECT * FROM sa_us_orders.src_us_order LIMIT 10;
SELECT * FROM sa_no_usa_orders.src_no_usa_order LIMIT 10;

-- Check specific cases, for example:
SELECT * FROM sa_us_orders.src_us_order WHERE customer_id = '29' AND contactlastname = 'old';

SELECT *
FROM sa_us_orders.ext_us_order us
WHERE NOT EXISTS (
    SELECT 1 
    FROM sa_us_orders.src_us_order src
    WHERE COALESCE(src.ordernumber, '') = COALESCE(us.ordernumber, '')
);

SELECT * FROM sa_us_orders.src_us_order WHERE ordernumber = '40050060';





-- creating schema
CREATE SCHEMA IF NOT EXISTS BL_3NF;

CREATE OR REPLACE PROCEDURE public.create_bl_3nf_and_tables_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Create CE_DEALSIZES table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_DEALSIZES (
        DEALSIZE_ID BIGINT PRIMARY KEY,
        DEALSIZE VARCHAR(50) NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        DEALSIZE_SRC_ID VARCHAR(100) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL
    );

    -- Create CE_PAYMENT_METHODS table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PAYMENT_METHODS (
        PAYMENT_METHOD_ID BIGINT PRIMARY KEY,
        PAYMENT_METHOD VARCHAR(50) NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        PAYMENT_SRC_ID VARCHAR(100) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL
    );

    -- Create CE_PRODUCTS table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PRODUCTS (
        PRODUCT_ID BIGINT PRIMARY KEY,
        PRODUCTCODE VARCHAR(50) NOT NULL,
        PRODUCTLINE VARCHAR(100) NOT NULL,
        PRICEEACH DECIMAL(15,2) NOT NULL,
        MSRP DECIMAL(15,2) NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        PRODUCT_SRC_ID VARCHAR(50) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL
    );

    -- Create CE_COUNTRIES table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_COUNTRIES (
        COUNTRY_ID BIGINT PRIMARY KEY,
        COUNTRY_NAME VARCHAR(100) NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        COUNTRY_SRC_ID VARCHAR(50) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL,
        CONSTRAINT unique_countries UNIQUE (COUNTRY_NAME)
    );

    -- Create CE_STATES table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_STATES (
        STATE_ID BIGINT PRIMARY KEY,
        STATE_NAME VARCHAR(100) NOT NULL,
        COUNTRY_ID BIGINT NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        STATE_SRC_ID VARCHAR(50) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL,
        FOREIGN KEY (COUNTRY_ID) REFERENCES BL_3NF.CE_COUNTRIES(COUNTRY_ID)
    );

    -- Create CE_CITIES table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_CITIES (
        CITY_ID BIGINT PRIMARY KEY,
        CITY_NAME VARCHAR(100) NOT NULL,
        STATE_ID BIGINT NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        CITY_SRC_ID VARCHAR(50) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL,
        FOREIGN KEY (STATE_ID) REFERENCES BL_3NF.CE_STATES(STATE_ID)
    );

    -- Create CE_ADDRESSES table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_ADDRESSES (
        ADDRESS_ID BIGINT PRIMARY KEY,
        ADDRESSLINE1 VARCHAR(100) NOT NULL,
        CITY_ID BIGINT NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        ADDRESS_SRC_ID VARCHAR(50) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL,
        FOREIGN KEY (CITY_ID) REFERENCES BL_3NF.CE_CITIES(CITY_ID)
    );

    -- Create CE_CUSTOMERS_SCD table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_CUSTOMERS_SCD (
        CUSTOMER_ID BIGINT PRIMARY KEY,
        CUSTOMERNAME VARCHAR(100) NOT NULL,
        CONTACTFIRSTNAME VARCHAR(100) NOT NULL,
        CONTACTLASTNAME VARCHAR(100) NOT NULL,
        PHONE VARCHAR(20) NOT NULL,
        ADDRESS_ID BIGINT NOT NULL,
        START_DT DATE NOT NULL,
        END_DT DATE NOT NULL,
        IS_ACTIVE VARCHAR(1) NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        CUSTOMER_SRC_ID VARCHAR(50) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL,
        FOREIGN KEY (ADDRESS_ID) REFERENCES BL_3NF.CE_ADDRESSES(ADDRESS_ID)
    );

    -- Create CE_ORDERS table
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_ORDERS (
        ORDERNUMBER BIGINT PRIMARY KEY,
        QUANTITYORDERED INTEGER NOT NULL,
        SALES DECIMAL(15,2) NOT NULL,
        PAYMENT_METHOD_ID BIGINT NOT NULL,
        DEALSIZE_ID BIGINT NOT NULL,
        PRODUCT_ID BIGINT NOT NULL,
        CUSTOMER_ID BIGINT NOT NULL,
        EVENT_DT DATE NOT NULL,
        TA_INSERT_DT DATE NOT NULL,
        TA_UPDATE_DT DATE NOT NULL,
        ORDER_SRC_ID VARCHAR(100) NOT NULL,
        SOURCE_SYSTEM VARCHAR(100) NOT NULL,
        SOURCE_ENTITY VARCHAR(100) NOT NULL,
        FOREIGN KEY (PAYMENT_METHOD_ID) REFERENCES BL_3NF.CE_PAYMENT_METHODS(PAYMENT_METHOD_ID),
        FOREIGN KEY (DEALSIZE_ID) REFERENCES BL_3NF.CE_DEALSIZES(DEALSIZE_ID),
        FOREIGN KEY (PRODUCT_ID) REFERENCES BL_3NF.CE_PRODUCTS(PRODUCT_ID),
        FOREIGN KEY (CUSTOMER_ID) REFERENCES BL_3NF.CE_CUSTOMERS_SCD(CUSTOMER_ID)
    );

    RAISE NOTICE 'BL_3NF tables are created';

EXCEPTION
    WHEN OTHERS THEN
        -- Raise the exception to propagate the error
        RAISE NOTICE 'BL_3NF tables are not created: %', SQLERRM;
END;
$$;

-- Call the procedure to create the tables
CALL public.create_bl_3nf_and_tables_procedure();


-- creating sequences

CREATE OR REPLACE PROCEDURE BL_3NF.create_sequences_for_3nf_tables_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Create sequences for CE_DEALSIZES
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.dealsize_id_seq;

    -- Create sequences for CE_PAYMENT_METHODS
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.payment_method_id_seq;

    -- Create sequences for CE_PRODUCTS
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.product_id_seq;

    -- Create sequences for CE_COUNTRIES
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.country_id_seq;

    -- Create sequences for CE_STATES
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.state_id_seq;

    -- Create sequences for CE_CITIES
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.city_id_seq;

    -- Create sequences for CE_ADDRESSES
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.address_id_seq;

    -- Create sequences for CE_CUSTOMERS_SCD
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.customer_id_seq;

    -- Create sequences for CE_ORDERS
    CREATE SEQUENCE IF NOT EXISTS bl_3nf.ordernumber_seq;

    RAISE NOTICE '3NF sequences are created';

EXCEPTION
    WHEN OTHERS THEN
        -- Raise the exception to propagate the error
        RAISE NOTICE '3NF sequences are not created: %', SQLERRM;
END;
$$;

-- Call the procedure to create the sequences
CALL BL_3NF.create_sequences_for_3nf_tables_procedure();




CREATE OR REPLACE PROCEDURE BL_3NF.insert_default_rows_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Inserting default row into CE_PAYMENT_METHODS
    INSERT INTO BL_3NF.CE_PAYMENT_METHODS (
        PAYMENT_METHOD_ID, PAYMENT_METHOD, TA_INSERT_DT, TA_UPDATE_DT, PAYMENT_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_PAYMENT_METHODS WHERE PAYMENT_METHOD_ID = -1);

    -- Inserting default row into CE_DEALSIZES
    INSERT INTO BL_3NF.CE_DEALSIZES (
        DEALSIZE_ID, DEALSIZE, TA_INSERT_DT, TA_UPDATE_DT, DEALSIZE_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_DEALSIZES WHERE DEALSIZE_ID = -1);

    -- Inserting default row into CE_PRODUCTS
    INSERT INTO BL_3NF.CE_PRODUCTS (
        PRODUCT_ID, PRODUCTCODE, PRODUCTLINE, PRICEEACH, MSRP, TA_INSERT_DT, TA_UPDATE_DT, PRODUCT_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', 'n. a.', -1, -1, '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_PRODUCTS WHERE PRODUCT_ID = -1);

    -- Inserting default row into CE_COUNTRIES
    INSERT INTO BL_3NF.CE_COUNTRIES (
        COUNTRY_ID, COUNTRY_NAME, TA_INSERT_DT, TA_UPDATE_DT, COUNTRY_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_COUNTRIES WHERE COUNTRY_ID = -1);

    -- Inserting default row into CE_STATES
    INSERT INTO BL_3NF.CE_STATES (
        STATE_ID, STATE_NAME, COUNTRY_ID, TA_INSERT_DT, TA_UPDATE_DT, STATE_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', -1, '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_STATES WHERE STATE_ID = -1);

    -- Inserting default row into CE_CITIES
    INSERT INTO BL_3NF.CE_CITIES (
        CITY_ID, CITY_NAME, STATE_ID, TA_INSERT_DT, TA_UPDATE_DT, CITY_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', -1, '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_CITIES WHERE CITY_ID = -1);

    -- Inserting default row into CE_ADDRESSES
    INSERT INTO BL_3NF.CE_ADDRESSES (
        ADDRESS_ID, ADDRESSLINE1, CITY_ID, TA_INSERT_DT, TA_UPDATE_DT, ADDRESS_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', -1, '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_ADDRESSES WHERE ADDRESS_ID = -1);

    -- Inserting default row into CE_CUSTOMERS_SCD
    INSERT INTO BL_3NF.CE_CUSTOMERS_SCD (
        CUSTOMER_ID, CUSTOMERNAME, CONTACTFIRSTNAME, CONTACTLASTNAME, PHONE, ADDRESS_ID, START_DT, END_DT, IS_ACTIVE, TA_INSERT_DT, CUSTOMER_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, 'n. a.', 'n. a.', 'n. a.', 'n. a.', -1, '1900-01-01', '9999-12-31', 'Y', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_CUSTOMERS_SCD WHERE CUSTOMER_ID = -1);

    -- Inserting default row into CE_ORDERS
    INSERT INTO BL_3NF.CE_ORDERS (
        ORDERNUMBER, QUANTITYORDERED, SALES, PAYMENT_METHOD_ID, DEALSIZE_ID, PRODUCT_ID, CUSTOMER_ID, EVENT_DT, TA_INSERT_DT, TA_UPDATE_DT, ORDER_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT -1, -1, -1, -1, -1, -1, -1, '1900-01-01', '1900-01-01', '1900-01-01', 'n. a.', 'MANUAL', 'MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_ORDERS WHERE ORDERNUMBER = -1);

    -- Commit the transaction
    COMMIT;

    RAISE NOTICE 'Default rows inserted into BL_3NF tables';

EXCEPTION
    WHEN OTHERS THEN
        -- Handle the exception and raise a notice
        RAISE NOTICE 'Error occurred while inserting default rows: %', SQLERRM;
END;
$$;

-- Call the procedure to insert default rows
CALL BL_3NF.insert_default_rows_procedure();



-- Creating necessary schemas
CREATE SCHEMA IF NOT EXISTS BL_CL;


-- Creating a centralized logging table in BL_CL schema
CREATE TABLE IF NOT EXISTS BL_CL.procedure_logs (
    log_id SERIAL PRIMARY KEY,
    log_timestamp TIMESTAMPTZ DEFAULT NOW(),
    procedure_name TEXT,
    rows_affected INT,
    log_message TEXT,
    error_message TEXT
);

-- Creating a logging function in BL_CL schema
CREATE OR REPLACE FUNCTION BL_CL.log_procedure_action(
    proc_name TEXT, 
    rows INT, 
    message TEXT, 
    error_message TEXT DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
    INSERT INTO BL_CL.procedure_logs (procedure_name, rows_affected, log_message, error_message)
    VALUES (proc_name, rows, message, error_message);
END;
$$ LANGUAGE plpgsql;


-- Creating procedure to load data into CE_DEALSIZES
CREATE OR REPLACE PROCEDURE BL_3NF.load_dealsizes()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_DEALSIZES (
            DEALSIZE_ID, DEALSIZE, DEALSIZE_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            COALESCE(
                (SELECT DEALSIZE_ID FROM BL_3NF.CE_DEALSIZES 
                 WHERE SOURCE_SYSTEM = combined.source_system
                   AND SOURCE_ENTITY = combined.source_entity
                   AND DEALSIZE_SRC_ID = combined.dealsize_src_id
                ),
                nextval('BL_3NF.dealsize_id_seq')
            ) AS DEALSIZE_ID,
            combined.dealsize,
            combined.dealsize AS dealsize_src_id,
            CURRENT_DATE,
            CURRENT_DATE,
            combined.source_system,
            combined.source_entity
        FROM (
            SELECT 
                dealsize, 
                'sa_us_orders' AS source_system, 
                'src_us_order' AS source_entity,
                dealsize AS dealsize_src_id
            FROM sa_us_orders.src_us_order
            UNION ALL
            SELECT 
                deal_size AS dealsize, 
                'sa_no_usa_orders' AS source_system, 
                'src_no_usa_order' AS source_entity,
                deal_size AS dealsize_src_id
            FROM sa_no_usa_orders.src_no_usa_order
        ) AS combined
        WHERE combined.dealsize IS NOT NULL 
          AND NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_DEALSIZES 
            WHERE SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
              AND DEALSIZE_SRC_ID = combined.dealsize_src_id
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_dealsizes', rows_affected, 'Dealsizes loaded successfully');
    EXCEPTION
        WHEN unique_violation THEN
            PERFORM BL_CL.log_procedure_action('load_dealsizes', 0, 'Unique constraint violation occurred');
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_dealsizes', 0, 'Error occurred during dealsizes load', SQLERRM);
            RAISE;
    END;
END;
$$;

-- Creating procedure to load data into CE_PAYMENT_METHODS
CREATE OR REPLACE PROCEDURE BL_3NF.load_payment_methods()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_PAYMENT_METHODS (
            PAYMENT_METHOD_ID, PAYMENT_METHOD, PAYMENT_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            COALESCE(
                (SELECT PAYMENT_METHOD_ID FROM BL_3NF.CE_PAYMENT_METHODS 
                 WHERE SOURCE_SYSTEM = combined.source_system
                   AND SOURCE_ENTITY = combined.source_entity
                   AND PAYMENT_SRC_ID = combined.payment_src_id
                ),
                nextval('BL_3NF.payment_method_id_seq')
            ) AS PAYMENT_METHOD_ID,
            combined.payment_method,
            combined.payment_method AS payment_src_id,
            CURRENT_DATE,
            CURRENT_DATE,
            combined.source_system,
            combined.source_entity
        FROM (
            SELECT 
                payment_method, 
                'sa_us_orders' AS source_system, 
                'src_us_order' AS source_entity,
                payment_method AS payment_src_id
            FROM sa_us_orders.src_us_order
            UNION ALL
            SELECT 
                payment_method, 
                'sa_no_usa_orders' AS source_system, 
                'src_no_usa_order' AS source_entity,
                payment_method AS payment_src_id
            FROM sa_no_usa_orders.src_no_usa_order
        ) AS combined
        WHERE combined.payment_method IS NOT NULL  
          AND NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_PAYMENT_METHODS 
            WHERE SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
              AND PAYMENT_SRC_ID = combined.payment_src_id
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_payment_methods', rows_affected, 'Payment methods loaded successfully');
    EXCEPTION
        WHEN unique_violation THEN
            PERFORM BL_CL.log_procedure_action('load_payment_methods', 0, 'Unique constraint violation occurred');
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_payment_methods', 0, 'Error occurred during payment methods load', SQLERRM);
            RAISE;
    END;
END;
$$;





-- Creating procedure to load data into CE_PRODUCTS
CREATE OR REPLACE PROCEDURE BL_3NF.load_products()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_PRODUCTS (
            PRODUCT_ID, PRODUCTCODE, PRODUCTLINE, PRICEEACH, MSRP, PRODUCT_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            COALESCE(
                (SELECT PRODUCT_ID FROM BL_3NF.CE_PRODUCTS 
                 WHERE SOURCE_SYSTEM = combined.source_system
                   AND SOURCE_ENTITY = combined.source_entity
                   AND PRODUCT_SRC_ID = combined.product_src_id
                ),
                nextval('BL_3NF.product_id_seq')
            ) AS PRODUCT_ID,
            combined.productcode,
            combined.productline,
            combined.priceeach::NUMERIC,
            combined.msrp::NUMERIC,
            combined.productcode AS product_src_id,
            CURRENT_DATE,
            CURRENT_DATE,
            combined.source_system,
            combined.source_entity
        FROM (
            SELECT 
                productcode, 
                productline, 
                priceeach::VARCHAR, 
                msrp::VARCHAR, 
                'sa_us_orders' AS source_system, 
                'src_us_order' AS source_entity,
                productcode AS product_src_id
            FROM sa_us_orders.src_us_order
            UNION ALL
            SELECT 
                product_model AS productcode, 
                product_line AS productline, 
                price_for_each AS priceeach, 
                ms_rp AS msrp, 
                'sa_no_usa_orders' AS source_system, 
                'src_no_usa_order' AS source_entity,
                product_model AS product_src_id
            FROM sa_no_usa_orders.src_no_usa_order
        ) AS combined
        WHERE combined.productcode IS NOT NULL 
          AND NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_PRODUCTS 
            WHERE SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
              AND PRODUCT_SRC_ID = combined.product_src_id
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_products', rows_affected, 'Products loaded successfully');
    EXCEPTION
        WHEN unique_violation THEN
            PERFORM BL_CL.log_procedure_action('load_products', 0, 'Unique constraint violation occurred');
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_products', 0, 'Error occurred during products load', SQLERRM);
            RAISE;
    END;
END;
$$;


-- Creating procedure to load data into CE_COUNTRIES
CREATE OR REPLACE PROCEDURE BL_3NF.load_countries()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_COUNTRIES (
            COUNTRY_ID, COUNTRY_NAME, COUNTRY_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            nextval('BL_3NF.country_id_seq'),
            country_name,
            country_src_id,
            CURRENT_DATE,
            CURRENT_DATE,
            source_system,
            source_entity
        FROM (
            SELECT COALESCE(country, 'n. a.') AS country_name, COALESCE(country, 'n. a.') AS country_src_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
            FROM sa_us_orders.src_us_order
            UNION ALL
            SELECT COALESCE(country_name, 'n. a.') AS country_name, COALESCE(country_name, 'n. a.') AS country_src_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
            FROM sa_no_usa_orders.src_no_usa_order
        ) AS combined
        WHERE NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_COUNTRIES 
            WHERE COUNTRY_SRC_ID = combined.country_src_id
              AND SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_countries', rows_affected, 'Countries loaded successfully');
    EXCEPTION
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_countries', 0, 'Error occurred during countries load', SQLERRM);
            RAISE;
    END;
END;
$$;


-- Creating procedure to load data into CE_STATES
CREATE OR REPLACE PROCEDURE BL_3NF.load_states()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_STATES (
            STATE_ID, STATE_NAME, STATE_SRC_ID, COUNTRY_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            nextval('BL_3NF.state_id_seq'),
            state_name,
            state_src_id,
            country_id,
            CURRENT_DATE,
            CURRENT_DATE,
            source_system,
            source_entity
        FROM (
            SELECT us.state AS state_name, COALESCE(us.state, 'n. a.') AS state_src_id, COALESCE(c.country_id, -1) AS country_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
            FROM sa_us_orders.src_us_order us
            LEFT JOIN BL_3NF.CE_COUNTRIES c
            ON us.country = c.COUNTRY_SRC_ID
            AND c.source_system = 'sa_us_orders'
            AND c.source_entity = 'src_us_order'
        ) AS combined
        WHERE NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_STATES 
            WHERE STATE_SRC_ID = combined.state_src_id
              AND SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_states', rows_affected, 'States loaded successfully');
    EXCEPTION
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_states', 0, 'Error occurred during states load', SQLERRM);
            RAISE;
    END;
END;
$$;


-- Creating procedure to load data into CE_CITIES
CREATE OR REPLACE PROCEDURE BL_3NF.load_cities()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_CITIES (
            CITY_ID, CITY_NAME, CITY_SRC_ID, STATE_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            nextval('BL_3NF.city_id_seq'),
            city_name,
            city_src_id,
            state_id,
            CURRENT_DATE,
            CURRENT_DATE,
            source_system,
            source_entity
        FROM (
            SELECT us.city AS city_name, COALESCE(us.city, 'n. a.') AS city_src_id, COALESCE(s.state_id, -1) AS state_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
            FROM sa_us_orders.src_us_order us
            LEFT JOIN BL_3NF.CE_STATES s 
            ON us.state = s.STATE_SRC_ID
            AND s.source_system = 'sa_us_orders'
            AND s.source_entity = 'src_us_order'
            UNION ALL
            SELECT nous.city_name AS city_name, COALESCE(nous.city_name, 'n. a.') AS city_src_id, -1 AS state_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
            FROM sa_no_usa_orders.src_no_usa_order nous
        ) AS combined
        WHERE NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_CITIES 
            WHERE CITY_SRC_ID = combined.city_src_id
              AND SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_cities', rows_affected, 'Cities loaded successfully');
    EXCEPTION
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_cities', 0, 'Error occurred during cities load', SQLERRM);
            RAISE;
    END;
END;
$$;


-- Creating procedure to load data into CE_ADDRESSES
CREATE OR REPLACE PROCEDURE BL_3NF.load_addresses()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    BEGIN
        INSERT INTO BL_3NF.CE_ADDRESSES (
            ADDRESS_ID, ADDRESSLINE1, ADDRESS_SRC_ID, CITY_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            nextval('BL_3NF.address_id_seq'),
            addressline1,
            address_src_id,
            city_id,
            CURRENT_DATE,
            CURRENT_DATE,
            source_system,
            source_entity
        FROM (
            SELECT COALESCE(us.addressline1, 'n. a.') AS addressline1, COALESCE(us.address_id::VARCHAR, 'n. a.') AS address_src_id, COALESCE(c.city_id, -1) AS city_id, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity
            FROM sa_us_orders.src_us_order us
            LEFT JOIN BL_3NF.CE_CITIES c 
            ON us.city = c.CITY_SRC_ID
            AND c.source_system = 'sa_us_orders'
            AND c.source_entity = 'src_us_order'
            UNION ALL
            SELECT COALESCE(nous.address_line, 'n. a.') AS addressline1, COALESCE(nous.address_id_num::VARCHAR, 'n. a.') AS address_src_id, COALESCE(c.city_id, -1) AS city_id, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity
            FROM sa_no_usa_orders.src_no_usa_order nous
            LEFT JOIN BL_3NF.CE_CITIES c 
            ON nous.city_name = c.CITY_SRC_ID
            AND c.source_system = 'sa_no_usa_orders'
            AND c.source_entity = 'src_no_usa_order'
        ) AS combined
        WHERE NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_ADDRESSES 
            WHERE ADDRESS_SRC_ID = combined.address_src_id
              AND SOURCE_SYSTEM = combined.source_system
              AND SOURCE_ENTITY = combined.source_entity
        );

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_addresses', rows_affected, 'Addresses loaded successfully');
    EXCEPTION
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_addresses', 0, 'Error occurred during addresses load', SQLERRM);
            RAISE;
    END;
END;
$$;

-- customersss------------------------------------------


CREATE OR REPLACE PROCEDURE BL_3NF.load_customers()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Mark existing records as inactive (End Date and Is Active)
    UPDATE BL_3NF.CE_CUSTOMERS_SCD c
    SET END_DT = CURRENT_DATE - INTERVAL '1 day', IS_ACTIVE = 'N'
    WHERE EXISTS (
        SELECT 1
        FROM (
            SELECT COALESCE(us.customer_id::VARCHAR, 'n. a.') AS CUSTOMER_SRC_ID, 'sa_us_orders' AS source_system, 'src_us_order' AS source_entity FROM sa_us_orders.src_us_order us
            UNION ALL
            SELECT COALESCE(nous.customers_id::VARCHAR, 'n. a.') AS CUSTOMER_SRC_ID, 'sa_no_usa_orders' AS source_system, 'src_no_usa_order' AS source_entity FROM sa_no_usa_orders.src_no_usa_order nous
        ) AS combined
        WHERE combined.CUSTOMER_SRC_ID = c.CUSTOMER_SRC_ID
          AND combined.source_system = c.source_system
          AND combined.source_entity = c.source_entity
          AND c.IS_ACTIVE = 'Y'
    );

    --  Insert new records while retaining the same CUSTOMER_ID
    INSERT INTO BL_3NF.CE_CUSTOMERS_SCD (
        CUSTOMER_ID, CUSTOMERNAME, CONTACTFIRSTNAME, CONTACTLASTNAME, PHONE, CUSTOMER_SRC_ID, ADDRESS_ID, START_DT, END_DT, IS_ACTIVE, TA_INSERT_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT DISTINCT
        COALESCE(
            (SELECT CUSTOMER_ID FROM BL_3NF.CE_CUSTOMERS_SCD c
             WHERE c.CUSTOMER_SRC_ID = combined.customer_src_id
               AND c.source_system = combined.source_system
               AND c.source_entity = combined.source_entity
               AND c.IS_ACTIVE = 'Y'),
            nextval('BL_3NF.customer_id_seq')
        ) AS CUSTOMER_ID,
        combined.customername,
        combined.contactfirstname,
        combined.contactlastname,
        combined.phone,
        combined.customer_src_id,
        combined.address_id,
        CURRENT_DATE,
        DATE '9999-12-31',
        'Y',
        CURRENT_DATE,
        combined.source_system,
        combined.source_entity
    FROM (
        SELECT 
            COALESCE(us.customername, 'n. a.') AS customername, 
            COALESCE(us.contactfirstname, 'n. a.') AS contactfirstname, 
            COALESCE(us.contactlastname, 'n. a.') AS contactlastname, 
            COALESCE(us.phone, 'n. a.') AS phone, 
            COALESCE(us.customer_id::VARCHAR, 'n. a.') AS customer_src_id, 
            COALESCE(a.address_id, -1) AS address_id, 
            'sa_us_orders' AS source_system, 
            'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_ADDRESSES a 
        ON us.addressline1 = a.addressline1
        AND a.source_system = 'sa_us_orders'
        AND a.source_entity = 'src_us_order'
        UNION ALL
        SELECT 
            COALESCE(nous.cust_name, 'n. a.') AS customername, 
            COALESCE(nous.cust_firstname, 'n. a.') AS contactfirstname, 
            COALESCE(nous.cust_lastname, 'n. a.') AS contactlastname, 
            COALESCE(nous.phone_number, 'n. a.') AS phone, 
            COALESCE(nous.customers_id::VARCHAR, 'n. a.') AS customer_src_id, 
            COALESCE(a.address_id, -1) AS address_id, 
            'sa_no_usa_orders' AS source_system, 
            'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order nous
        LEFT JOIN BL_3NF.CE_ADDRESSES a 
        ON nous.address_line = a.addressline1
        AND a.source_system = 'sa_no_usa_orders'
        AND a.source_entity = 'src_no_usa_order'
    ) AS combined
    LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
    ON combined.customer_src_id = c.CUSTOMER_SRC_ID
    AND combined.source_system = c.source_system
    AND combined.source_entity = c.source_entity
    WHERE c.customer_id IS NULL
    OR c.IS_ACTIVE = 'N';

    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    PERFORM BL_CL.log_procedure_action('load_customers', rows_affected, 'Customers loaded successfully with SCD Type 2');
EXCEPTION
    WHEN unique_violation THEN
        -- Handle specific unique_violation
        PERFORM BL_CL.log_procedure_action('load_customers', 0, 'Unique constraint violation occurred');
        -- Implement retry logic or additional handling if needed
    WHEN OTHERS THEN
        PERFORM BL_CL.log_procedure_action('load_customers', 0, 'Error occurred during customers load', SQLERRM);
        RAISE;
END;
$$;





-- Creating procedure to load data into CE_ORDERS with full incremental logic
CREATE OR REPLACE PROCEDURE BL_3NF.load_orders()
LANGUAGE plpgsql AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records and update existing ones based on ta_insert_dt or ta_update_dt
    BEGIN
        -- Insert new records
        INSERT INTO BL_3NF.CE_ORDERS (
            ORDERNUMBER, QUANTITYORDERED, SALES, PAYMENT_METHOD_ID, DEALSIZE_ID, PRODUCT_ID, CUSTOMER_ID, EVENT_DT, TA_INSERT_DT, TA_UPDATE_DT, ORDER_SRC_ID, SOURCE_SYSTEM, SOURCE_ENTITY
        )
        SELECT DISTINCT
            COALESCE(
                (SELECT ORDERNUMBER FROM BL_3NF.CE_ORDERS 
                 WHERE ORDER_SRC_ID = us.ordernumber::VARCHAR
                   AND SOURCE_SYSTEM = 'sa_us_orders'
                   AND SOURCE_ENTITY = 'src_us_order'),
                nextval('BL_3NF.ordernumber_seq')
            ) AS ordernumber,
            us.quantityordered::INTEGER AS quantityordered,
            us.sales::NUMERIC AS sales,
            pm.PAYMENT_METHOD_ID AS payment_method_id,
            ds.DEALSIZE_ID AS dealsize_id,
            p.PRODUCT_ID AS product_id,
            c.CUSTOMER_ID AS customer_id,
            us.orderdate::DATE AS event_dt,
            us.ta_insert_dt,
            CURRENT_TIMESTAMP AS ta_update_dt,
            us.ordernumber::VARCHAR AS order_src_id,
            'sa_us_orders' AS source_system,
            'src_us_order' AS source_entity
        FROM sa_us_orders.src_us_order us
        LEFT JOIN BL_3NF.CE_PAYMENT_METHODS pm 
        ON us.payment_method = pm.PAYMENT_METHOD
        AND pm.payment_src_id = us.payment_method
        AND pm.source_system = 'sa_us_orders'
        AND pm.source_entity = 'src_us_order'
        LEFT JOIN BL_3NF.CE_DEALSIZES ds 
        ON us.dealsize = ds.DEALSIZE
        AND ds.dealsize_src_id = us.dealsize
        AND ds.source_system = 'sa_us_orders'
        AND ds.source_entity = 'src_us_order'
        LEFT JOIN BL_3NF.CE_PRODUCTS p 
        ON us.productcode = p.PRODUCTCODE
        AND p.product_src_id = us.productcode
        AND p.source_system = 'sa_us_orders'
        AND p.source_entity = 'src_us_order'
        LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
        ON us.customer_id::BIGINT = c.CUSTOMER_ID
        AND c.customer_src_id = us.customer_id::VARCHAR
        AND c.source_system = 'sa_us_orders'
        AND c.source_entity = 'src_us_order'
        WHERE us.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_3NF.CE_ORDERS)
        AND NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_ORDERS o 
            WHERE o.ORDER_SRC_ID = us.ordernumber::VARCHAR
              AND o.SOURCE_SYSTEM = 'sa_us_orders'
              AND o.SOURCE_ENTITY = 'src_us_order'
        )
        UNION ALL
        SELECT DISTINCT
            COALESCE(
                (SELECT ORDERNUMBER FROM BL_3NF.CE_ORDERS 
                 WHERE ORDER_SRC_ID = nous.order_id::VARCHAR
                   AND SOURCE_SYSTEM = 'sa_no_usa_orders'
                   AND SOURCE_ENTITY = 'src_no_usa_order'),
                nextval('BL_3NF.ordernumber_seq')
            ) AS ordernumber,
            nous.quantity::INTEGER AS quantityordered,
            nous.sales_amount::NUMERIC AS sales,
            pm.PAYMENT_METHOD_ID AS payment_method_id,
            ds.DEALSIZE_ID AS dealsize_id,
            p.PRODUCT_ID AS product_id,
            c.CUSTOMER_ID AS customer_id,
            nous.date_of_order::DATE AS event_dt,
            nous.ta_insert_dt,
            CURRENT_TIMESTAMP AS ta_update_dt,
            nous.order_id::VARCHAR AS order_src_id,
            'sa_no_usa_orders' AS source_system,
            'src_no_usa_order' AS source_entity
        FROM sa_no_usa_orders.src_no_usa_order nous
        LEFT JOIN BL_3NF.CE_PAYMENT_METHODS pm 
        ON nous.payment_method = pm.PAYMENT_METHOD
        AND pm.payment_src_id = nous.payment_method
        AND pm.source_system = 'sa_no_usa_orders'
        AND pm.source_entity = 'src_no_usa_order'
        LEFT JOIN BL_3NF.CE_DEALSIZES ds 
        ON nous.deal_size = ds.DEALSIZE
        AND ds.dealsize_src_id = nous.deal_size
        AND ds.source_system = 'sa_no_usa_orders'
        AND ds.source_entity = 'src_no_usa_order'
        LEFT JOIN BL_3NF.CE_PRODUCTS p 
        ON nous.product_model = p.PRODUCTCODE
        AND p.product_src_id = nous.product_model
        AND p.source_system = 'sa_no_usa_orders'
        AND p.source_entity = 'src_no_usa_order'
        LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
        ON nous.customers_id::BIGINT = c.CUSTOMER_ID
        AND c.customer_src_id = nous.customers_id::VARCHAR
        AND c.source_system = 'sa_no_usa_orders'
        AND c.source_entity = 'src_no_usa_order'
        WHERE nous.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_3NF.CE_ORDERS)
        AND NOT EXISTS (
            SELECT 1 FROM BL_3NF.CE_ORDERS o 
            WHERE o.ORDER_SRC_ID = nous.order_id::VARCHAR
              AND o.SOURCE_SYSTEM = 'sa_no_usa_orders'
              AND o.SOURCE_ENTITY = 'src_no_usa_order'
        );

        -- Update existing records
        UPDATE BL_3NF.CE_ORDERS o
        SET 
            QUANTITYORDERED = src.quantityordered::INTEGER,
            SALES = src.sales::NUMERIC,
            PAYMENT_METHOD_ID = pm.PAYMENT_METHOD_ID,
            DEALSIZE_ID = ds.DEALSIZE_ID,
            PRODUCT_ID = p.PRODUCT_ID,
            CUSTOMER_ID = c.CUSTOMER_ID,
            EVENT_DT = src.event_dt::DATE,
            TA_UPDATE_DT = CURRENT_TIMESTAMP
        FROM (
            SELECT us.* 
            FROM sa_us_orders.src_us_order us
            WHERE us.ta_update_dt >= (SELECT COALESCE(MAX(ta_update_dt), '1900-01-01'::timestamp) FROM BL_3NF.CE_ORDERS)
            UNION ALL
            SELECT nous.*
            FROM sa_no_usa_orders.src_no_usa_order nous
            WHERE nous.ta_update_dt >= (SELECT COALESCE(MAX(ta_update_dt), '1900-01-01'::timestamp) FROM BL_3NF.CE_ORDERS)
        ) src
        LEFT JOIN BL_3NF.CE_PAYMENT_METHODS pm 
        ON src.payment_method = pm.PAYMENT_METHOD
        AND pm.payment_src_id = src.payment_method
        AND pm.source_system = src.source_system
        AND pm.source_entity = src.source_entity
        LEFT JOIN BL_3NF.CE_DEALSIZES ds 
        ON src.dealsize = ds.DEALSIZE
        AND ds.dealsize_src_id = src.dealsize
        AND ds.source_system = src.source_system
        AND ds.source_entity = src.source_entity
        LEFT JOIN BL_3NF.CE_PRODUCTS p 
        ON src.productcode = p.PRODUCTCODE
        AND p.product_src_id = src.productcode
        AND p.source_system = src.source_system
        AND p.source_entity = src.source_entity
        LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
        ON src.customer_id::BIGINT = c.CUSTOMER_ID
        AND c.customer_src_id = src.customer_id::VARCHAR
        AND c.source_system = src.source_system
        AND c.source_entity = src.source_entity
        WHERE o.ORDER_SRC_ID = src.ordernumber::VARCHAR
        AND o.SOURCE_SYSTEM = src.source_system
        AND o.SOURCE_ENTITY = src.source_entity;

        GET DIAGNOSTICS rows_affected = ROW_COUNT;
        PERFORM BL_CL.log_procedure_action('load_orders', rows_affected, 'Orders loaded successfully');
    EXCEPTION
        WHEN unique_violation THEN
            PERFORM BL_CL.log_procedure_action('load_orders', 0, 'Duplicate order number found and skipped');
        WHEN OTHERS THEN
            PERFORM BL_CL.log_procedure_action('load_orders', 0, 'Error occurred during orders load', SQLERRM);
            RAISE;
    END;
END;
$$;






-- Call the procedure to insert data into CE_DEALSIZES
CALL BL_3NF.insert_ce_dealsizes_procedure();

-- Call the procedure to insert data into CE_PAYMENT_METHODS
CALL BL_3NF.insert_ce_payment_methods_procedure();

-- Call the procedure to insert data into CE_PRODUCTS
CALL BL_3NF.insert_ce_products_procedure();

-- Call the procedure to insert data into CE_COUNTRIES
CALL BL_3NF.insert_ce_countries_procedure();

-- Call the procedure to insert data into CE_STATES
CALL BL_3NF.insert_ce_states_procedure();

-- Call the procedure to insert data into CE_CITIES
CALL BL_3NF.insert_ce_cities_procedure();

-- Call the procedure to insert data into CE_ADDRESSES
CALL BL_3NF.insert_ce_addresses_procedure();

-- Call the procedure to insert data into CE_CUSTOMERS_SCD
CALL BL_3NF.load_customers();


-- Call the procedure to insert data into CE_ORDERS

CALL BL_3NF.insert_ce_orders_procedure();



select * from bl_3nf.ce_customers_scd ccs
where customer_src_id= '29'; 

select * from sa_us_orders.src_us_order where customer_id= '29'and src_us_order.contactlastname ='old' ; 
-- creating dm
CREATE OR REPLACE PROCEDURE bl_dm.create_dim_and_fct_tables_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Create dim_dealsizes table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_dealsizes (
        dealsize_surr_id BIGINT PRIMARY KEY,
        dealsize_src_id VARCHAR(100) NOT NULL UNIQUE,
        dealsize VARCHAR(50) NOT NULL UNIQUE,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_payment_methods table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_payment_methods (
        payment_method_surr_id BIGINT PRIMARY KEY,
        payment_method_src_id VARCHAR(100) NOT NULL UNIQUE,
        payment_method VARCHAR(50) NOT NULL UNIQUE,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_customers table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_customers_scd (
        customer_surr_id BIGINT PRIMARY KEY,
        customer_src_id VARCHAR(100) NOT NULL,
        customername VARCHAR(100) NOT NULL,
        contactfirstname VARCHAR(100) NOT NULL,
        contactlastname VARCHAR(100) NOT NULL,
        phone VARCHAR(100) NOT NULL,
        addressline1 VARCHAR(100) NOT NULL,
        city_id BIGINT NOT NULL,
        city VARCHAR(100) NOT NULL,
        state_id BIGINT NOT NULL,
        state VARCHAR(100) NOT NULL,
        country_id BIGINT NOT NULL,
        country VARCHAR(100) NOT NULL,
        start_dt DATE NOT NULL,
        end_dt DATE NOT NULL,
        is_active VARCHAR(1) NOT NULL,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_products table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_products (
        product_surr_id BIGINT PRIMARY KEY,
        product_src_id VARCHAR(100) NOT NULL UNIQUE,
        productcode VARCHAR(50) NOT NULL UNIQUE,
        productline VARCHAR(100) NOT NULL,
        priceeach DECIMAL(15,2) NOT NULL,
        msrp DECIMAL(15,2) NOT NULL,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_dates table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_dates (
        date_src_id VARCHAR(100) PRIMARY KEY,
        day_id INTEGER NOT NULL,
        month_id INTEGER NOT NULL,
        year_id INTEGER NOT NULL,
        qrt_id INTEGER NOT NULL,
        week_id INTEGER NOT NULL
    );

    -- Create fct_orders table
    CREATE TABLE IF NOT EXISTS bl_dm.fct_orders (
        ordernumber_src_id VARCHAR(100) PRIMARY KEY,
        payment_method_surr_id BIGINT NOT NULL,
        dealsize_surr_id BIGINT NOT NULL,
        product_surr_id BIGINT NOT NULL,
        customer_surr_id BIGINT NOT NULL,
        date_src_id VARCHAR(100) NOT NULL,
        sales DECIMAL(15,2) NOT NULL,
        quantityordered INTEGER NOT NULL,
        total_cost DECIMAL(15,2) NOT NULL,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        event_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL,
        FOREIGN KEY (payment_method_surr_id) REFERENCES bl_dm.dim_payment_methods(payment_method_surr_id),
        FOREIGN KEY (dealsize_surr_id) REFERENCES bl_dm.dim_dealsizes(dealsize_surr_id),
        FOREIGN KEY (product_surr_id) REFERENCES bl_dm.dim_products(product_surr_id),
        FOREIGN KEY (customer_surr_id) REFERENCES bl_dm.dim_customers_scd(customer_surr_id),
        FOREIGN KEY (date_src_id) REFERENCES bl_dm.dim_dates(date_src_id)
    );

    RAISE NOTICE 'Tables created successfully';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred during table creation: %', SQLERRM;
END;
$$;




CREATE OR REPLACE PROCEDURE bl_dm.insert_default_values_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Insert default row into dim_dealsizes
    INSERT INTO bl_dm.dim_dealsizes (
        dealsize_surr_id, dealsize_src_id, dealsize, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_dealsizes WHERE dealsize_surr_id = -1);

    -- Insert default row into dim_payment_methods
    INSERT INTO bl_dm.dim_payment_methods (
        payment_method_surr_id, payment_method_src_id, payment_method, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_payment_methods WHERE payment_method_surr_id = -1);

    -- Insert default row into dim_customers
    INSERT INTO bl_dm.dim_customers_scd (
        customer_surr_id, customer_src_id, customername, contactfirstname, contactlastname, phone, addressline1, city_id, city, state_id, state, country_id, country, start_dt, end_dt, is_active, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', 'n. a.', 'n. a.', 'n. a.', 'n. a.', -1, 'n. a.', -1, 'n. a.', -1, 'n. a.', '1900-01-01', '9999-12-31', 'Y', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_customers_scd WHERE customer_surr_id = -1);

    -- Insert default row into dim_products
    INSERT INTO bl_dm.dim_products (
        product_surr_id, product_src_id, productcode, productline, priceeach, msrp, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', 'n. a.', -1, -1, '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_products WHERE product_surr_id = -1);

    -- Insert default row into dim_dates
    INSERT INTO bl_dm.dim_dates (
        date_src_id, day_id, month_id, year_id, qrt_id, week_id
    )
    SELECT 'n. a.', -1, -1, -1, -1, -1
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_dates WHERE date_src_id = 'n. a.');

    -- Insert default row into fct_orders
    INSERT INTO bl_dm.fct_orders (
        ordernumber_src_id, payment_method_surr_id, dealsize_surr_id, product_surr_id, customer_surr_id, date_src_id, sales, quantityordered, total_cost, ta_insert_dt, ta_update_dt, event_dt, source_system, source_entity
    )
    SELECT 'n. a.', -1, -1, -1, -1, 'n. a.', -1, 1, -1, '1900-01-01', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.fct_orders WHERE ordernumber_src_id = 'n. a.');

    RAISE NOTICE 'Default values inserted successfully';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred during default value insertion: %', SQLERRM;
END;
$$;



CALL bl_dm.create_dim_and_fct_tables_procedure();
CALL bl_dm.insert_default_values_procedure();


-----------------------------------------------------------------------------------------------------
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_dealsize_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_payment_method_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_product_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_country_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_state_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_city_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_address_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_customer_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_order_id_seq;


-- here i check index if they exist and making sure they do exsit

CREATE OR REPLACE PROCEDURE BL_DM.load_dm_dealsizes()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_DEALSIZES
    INSERT INTO BL_DM.DIM_DEALSIZES (
        DEALSIZE_SURR_ID, DEALSIZE, DEALSIZE_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT DISTINCT
        ds.dealsize_id AS dealsize_surr_id,
        ds.dealsize,
        ds.dealsize_src_id,
        ds.ta_insert_dt,
        ds.ta_update_dt,
        ds.source_system,
        ds.source_entity
    FROM BL_3NF.CE_DEALSIZES ds
    WHERE ds.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_DM.fct_orders)
    AND NOT EXISTS (
        SELECT 1 FROM BL_DM.DIM_DEALSIZES dds
        WHERE dds.dealsize_surr_id = ds.dealsize_id
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_dealsizes', rows_affected, 'Dealsizes loaded successfully into DM');
END;
$$;


-- payment methods ---------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_payment_methods()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_PAYMENT_METHODS
    INSERT INTO BL_DM.DIM_PAYMENT_METHODS (
        PAYMENT_METHOD_SURR_ID, PAYMENT_METHOD, PAYMENT_METHOD_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT DISTINCT
        pm.payment_method_id AS payment_method_surr_id,
        pm.payment_method,
        pm.payment_src_id, 
        pm.ta_insert_dt,
        pm.ta_update_dt,
        pm.source_system,
        pm.source_entity
    FROM BL_3NF.CE_PAYMENT_METHODS pm
    WHERE pm.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_DM.DIM_PAYMENT_METHODS)
    AND NOT EXISTS (
        SELECT 1 FROM BL_DM.DIM_PAYMENT_METHODS dpm
        WHERE dpm.payment_method_surr_id = pm.payment_method_id
    );

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_payment_methods', rows_affected, 'Payment methods loaded successfully into DM');
END;
$$;


   

-- Procedure to load data into DIM_DATES----------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_dates()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_DATES
    INSERT INTO BL_DM.dim_dates (
        date_id, day_id, month_id, year_id, qrt_id, week_id
    )
    SELECT DISTINCT
        TO_CHAR(event_dt::DATE, 'YYYYMMDD')::BIGINT AS date_id,  -- Using YYYYMMDD format as date_id
        EXTRACT(DAY FROM event_dt::DATE) AS day_id,
        EXTRACT(MONTH FROM event_dt::DATE) AS month_id,
        EXTRACT(YEAR FROM event_dt::DATE) AS year_id,
        EXTRACT(QUARTER FROM event_dt::DATE) AS qrt_id,
        EXTRACT(WEEK FROM event_dt::DATE) AS week_id
    FROM (
        SELECT event_dt FROM BL_3NF.CE_ORDERS
       
    ) AS events
    WHERE NOT EXISTS (
        SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = TO_CHAR(events.event_dt::DATE, 'YYYYMMDD')::BIGINT
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_dates', rows_affected, 'Dates loaded successfully into DIM_DATES');
END;
$$;




-- Procedure to load data into DIM_PRODUCTS-------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_products()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_PRODUCTS
    INSERT INTO BL_DM.DIM_PRODUCTS (
        product_surr_id, product_src_id, productcode, productline, priceeach, msrp, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT DISTINCT
        p.product_id AS product_surr_id,
        p.product_src_id,
        p.productcode,
        p.productline,
        p.priceeach,
        p.msrp,
        p.ta_insert_dt,
        CURRENT_TIMESTAMP AS ta_update_dt,
        p.source_system,
        p.source_entity
    FROM BL_3NF.CE_PRODUCTS p
    WHERE p.ta_insert_dt >= (
        SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) 
        FROM BL_DM.DIM_PRODUCTS
    )
    AND NOT EXISTS (
        SELECT 1 FROM BL_DM.DIM_PRODUCTS d
        WHERE d.product_surr_id = p.product_id
          AND d.product_src_id = p.product_src_id
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_products', rows_affected, 'Products loaded successfully into DIM_PRODUCTS');
END;
$$;




-- customers -------------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE bl_dm.load_dm_customers()
LANGUAGE plpgsql
AS $$
DECLARE
    rec RECORD;
    v_existing_customer RECORD;
BEGIN
    -- Ensure the sequence is aligned with the highest customer_surr_id
    PERFORM setval('bl_dm.customer_surr_id_seq', (SELECT COALESCE(MAX(customer_surr_id), 0) FROM bl_dm.dim_customers_scd) + 1, false);

    FOR rec IN
        SELECT DISTINCT
            c.customer_src_id,
            c.customername,
            c.contactfirstname,
            c.contactlastname,
            c.phone,
            a.addressline1,
            COALESCE(ct.city_id, -1) AS city_id,
            COALESCE(ct.city_name, 'n. a.') AS city,
            COALESCE(st.state_id, -1) AS state_id,
            COALESCE(st.state_name, 'n. a.') AS state,
            COALESCE(co.country_id, -1) AS country_id,
            COALESCE(co.country_name, 'n. a.') AS country,
            c.source_system,
            c.source_entity
        FROM BL_3NF.CE_CUSTOMERS_SCD c
        LEFT JOIN BL_3NF.CE_ADDRESSES a ON c.address_id = a.address_id
        LEFT JOIN BL_3NF.CE_CITIES ct ON a.city_id = ct.city_id
        LEFT JOIN BL_3NF.CE_STATES st ON ct.state_id = st.state_id
        LEFT JOIN BL_3NF.CE_COUNTRIES co ON st.country_id = co.country_id
        WHERE c.customer_src_id <> '-1'
    LOOP
        -- Check if the customer exists
        SELECT * INTO v_existing_customer
        FROM bl_dm.dim_customers_scd
        WHERE customer_src_id = rec.customer_src_id
          AND source_system = rec.source_system
          AND source_entity = rec.source_entity;

        IF FOUND THEN
            -- Update the existing record to mark it as inactive and set end date
            UPDATE bl_dm.dim_customers_scd
            SET 
                end_dt = CURRENT_DATE,
                is_active = 'N',
                ta_update_dt = CURRENT_TIMESTAMP
            WHERE customer_src_id = rec.customer_src_id
              AND source_system = rec.source_system
              AND source_entity = rec.source_entity
              AND is_active = 'Y'; -- Only update active records
        END IF;

        -- Insert the new record as active
        INSERT INTO bl_dm.dim_customers_scd (
            customer_surr_id, customer_src_id, customername, contactfirstname, contactlastname, 
            phone, addressline1, city_id, city, state_id, state, country_id, country,
            start_dt, end_dt, is_active, ta_insert_dt, ta_update_dt, 
            source_system, source_entity
        )
        VALUES (
            nextval('bl_dm.customer_surr_id_seq'), rec.customer_src_id, rec.customername, 
            rec.contactfirstname, rec.contactlastname, rec.phone, rec.addressline1, 
            rec.city_id, rec.city, rec.state_id, rec.state, rec.country_id, rec.country, 
            CURRENT_DATE, '9999-12-31'::DATE, 'Y', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 
            rec.source_system, rec.source_entity
        );
    END LOOP;
END;
$$;


-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders (
    ordernumber BIGINT,
    payment_method_surr_id INT,
    dealsize_surr_id INT,
    product_surr_id INT,
    customer_surr_id INT,
    date_id BIGINT,
    sales NUMERIC,
    quantityordered INT,
    total_cost NUMERIC,
    ta_insert_dt TIMESTAMP,
    ta_update_dt TIMESTAMP,
    event_dt DATE,
    source_system TEXT,
    source_entity TEXT,
    CONSTRAINT pk_fct_orders PRIMARY KEY (ordernumber, event_dt),
    CONSTRAINT fk_payment_method FOREIGN KEY (payment_method_surr_id) REFERENCES BL_DM.dim_payment_methods(payment_method_surr_id),
    CONSTRAINT fk_dealsize FOREIGN KEY (dealsize_surr_id) REFERENCES BL_DM.dim_dealsizes(dealsize_surr_id),
    CONSTRAINT fk_product FOREIGN KEY (product_surr_id) REFERENCES BL_DM.dim_products(product_surr_id),
    CONSTRAINT fk_customer FOREIGN KEY (customer_surr_id) REFERENCES BL_DM.dim_customers(customer_surr_id),
    CONSTRAINT fk_date FOREIGN KEY (date_id) REFERENCES BL_DM.dim_dates(date_id)
) PARTITION BY RANGE (event_dt);

-- Drop any existing partitions that might be conflicting
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_10;
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_11;
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_12;

-- Recreate the partitions with non-overlapping ranges
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_10 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-10-01') TO ('2005-11-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_11 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-11-01') TO ('2005-12-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_12 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-12-01') TO ('2006-01-01');
   
   
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_up_to_2024_05 PARTITION OF BL_DM.fct_orders
FOR VALUES FROM ('1900-01-01') TO ('2005-09-30');






   
 CREATE TABLE IF NOT EXISTS bl_cl.operation_log (
    log_id SERIAL PRIMARY KEY,
    log_type CHAR(1),
    procedure_name TEXT,
    table_name TEXT,
    rows_affected INT,
    execution_time NUMERIC,
    message TEXT,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
  
   
   
CREATE OR REPLACE PROCEDURE BL_DM.manage_fct_orders_partitions()
LANGUAGE plpgsql
AS $$
DECLARE
    partition_name text := FORMAT('fct_orders_%s', TO_CHAR(date_trunc('month', current_date), 'YYYY_MM'));
    old_partition_name TEXT := FORMAT('fct_orders_%s', TO_CHAR(date_trunc('month', current_date) - INTERVAL '3 month', 'YYYY_MM'));
    partition_start_date date := date_trunc('month', current_date);
    partition_end_date date := partition_start_date + INTERVAL '1 month';
    rows_affected int;
    start_time timestamp;
    end_time timestamp;
    execution_time numeric;
    message varchar(500);
   
BEGIN
    start_time := CLOCK_TIMESTAMP();

    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        
        EXECUTE FORMAT('SELECT COUNT(*) FROM bl_dm.%I', old_partition_name) INTO rows_affected;
    
        EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS bl_dm.%I PARTITION OF bl_dm.fct_orders FOR VALUES FROM (%L) TO (%L);',
                        partition_name, partition_start_date, partition_end_date);                 
        
        EXECUTE FORMAT('ALTER TABLE bl_dm.fct_orders DETACH PARTITION bl_dm.%I', 
                        old_partition_name); 
                       
        EXECUTE FORMAT('INSERT INTO bl_dm.fct_orders_archived
                        SELECT * FROM bl_dm.%I',
                        old_partition_name);
                       
        EXECUTE FORMAT('DROP TABLE bl_dm.%I', 
                        old_partition_name);
        
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);
        message := FORMAT('Created new partition bl_dm.%s, archived partition bl_dm.%I', 
                           partition_name, old_partition_name);
        
        -- Log the operation
        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('P', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', rows_affected, execution_time, message);
       
    ELSE 
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);

        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('N', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', 0, execution_time, 'Current partition already exists.');
    END IF;
     
EXCEPTION
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS
        message = MESSAGE_TEXT;
        
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);
        
        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('E', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', 0, execution_time, message);
        
        RAISE NOTICE 'Error occurred: %', message;
END;
$$;


call BL_DM.manage_fct_orders_partitions()





-- order

CREATE OR REPLACE PROCEDURE BL_DM.load_dm_orders()
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO BL_DM.fct_orders (
        ordernumber, 
        payment_method_surr_id, 
        dealsize_surr_id, 
        product_surr_id, 
        customer_surr_id, 
        date_id, 
        sales, 
        quantityordered, 
        total_cost, 
        ta_insert_dt, 
        ta_update_dt, 
        event_dt, 
        source_system, 
        source_entity
    )
    SELECT DISTINCT
       o.ordernumber::BIGINT AS ordernumber,
        o.payment_method_id AS payment_method_surr_id,
        o.dealsize_id AS dealsize_surr_id,
        o.product_id AS product_surr_id,
        o.customer_id AS customer_surr_id,
        COALESCE(TO_CHAR(o.event_dt, 'DDMMYYYY')::INT8, -1) AS date_id,
        o.sales,
        o.quantityordered,
        (o.sales * o.quantityordered) AS total_cost,
        o.ta_insert_dt,
        CURRENT_TIMESTAMP AS ta_update_dt,
        o.event_dt,
        o.source_system,
        o.source_entity
    FROM BL_3NF.CE_ORDERS o
    WHERE o.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_DM.fct_orders)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = COALESCE(TO_CHAR(o.event_dt, 'DDMMYYYY')::INT8, -1))
    AND EXISTS (SELECT 1 FROM BL_DM.dim_customers c WHERE c.customer_surr_id = o.customer_id)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_payment_methods pm WHERE pm.payment_method_surr_id = o.payment_method_id)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_dealsizes ds WHERE ds.dealsize_surr_id = o.dealsize_id)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_products p WHERE p.product_surr_id = o.product_id)
    ON CONFLICT (ordernumber, event_dt)
    DO UPDATE SET
        payment_method_surr_id = EXCLUDED.payment_method_surr_id,
        dealsize_surr_id = EXCLUDED.dealsize_surr_id,
        product_surr_id = EXCLUDED.product_surr_id,
        customer_surr_id = EXCLUDED.customer_surr_id,
        date_id = EXCLUDED.date_id,
        sales = EXCLUDED.sales,
        quantityordered = EXCLUDED.quantityordered,
        total_cost = EXCLUDED.total_cost,
        ta_update_dt = CURRENT_TIMESTAMP,
        source_system = EXCLUDED.source_system,
        source_entity = EXCLUDED.source_entity;
    
    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_orders', 0, 'Orders loaded/updated successfully into DM');
EXCEPTION
    WHEN OTHERS THEN
        PERFORM BL_3NF.log_procedure_action('load_dm_orders', 0, 'Error during order load: ' || SQLERRM);
        RAISE;
END;
$$;





-- Execute the procedures
CALL BL_DM.load_dm_dealsizes();
CALL BL_DM.load_dm_payment_methods();
CALL BL_DM.load_dm_customers();
CALL BL_DM.load_dm_products();
CALL BL_DM.load_dm_dates();
CALL BL_DM.load_dm_orders();


-- Verify data in DM tables
SELECT * FROM BL_DM.DIM_DEALSIZES ;
SELECT * FROM BL_DM.DIM_PAYMENT_METHODS;
select * from bl_dm.dim_customers dcs ;
SELECT * FROM BL_DM.DIM_PRODUCTS LIMIT 10;
SELECT * FROM BL_DM.DIM_DATES LIMIT 10;

-- Verify data in the fact table
SELECT * FROM BL_DM.FCT_ORDERS LIMIT 10;






























