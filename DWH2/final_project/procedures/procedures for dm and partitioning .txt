

-- creating dm
CREATE OR REPLACE PROCEDURE bl_dm.create_dim_and_fct_tables_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Create dim_dealsizes table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_dealsizes (
        dealsize_surr_id BIGINT PRIMARY KEY,
        dealsize_src_id VARCHAR(100) NOT NULL UNIQUE,
        dealsize VARCHAR(50) NOT NULL UNIQUE,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_payment_methods table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_payment_methods (
        payment_method_surr_id BIGINT PRIMARY KEY,
        payment_method_src_id VARCHAR(100) NOT NULL UNIQUE,
        payment_method VARCHAR(50) NOT NULL UNIQUE,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_customers table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_customers_scd (
        customer_surr_id BIGINT PRIMARY KEY,
        customer_src_id VARCHAR(100) NOT NULL,
        customername VARCHAR(100) NOT NULL,
        contactfirstname VARCHAR(100) NOT NULL,
        contactlastname VARCHAR(100) NOT NULL,
        phone VARCHAR(100) NOT NULL,
        addressline1 VARCHAR(100) NOT NULL,
        city_id BIGINT NOT NULL,
        city VARCHAR(100) NOT NULL,
        state_id BIGINT NOT NULL,
        state VARCHAR(100) NOT NULL,
        country_id BIGINT NOT NULL,
        country VARCHAR(100) NOT NULL,
        start_dt DATE NOT NULL,
        end_dt DATE NOT NULL,
        is_active VARCHAR(1) NOT NULL,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_products table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_products (
        product_surr_id BIGINT PRIMARY KEY,
        product_src_id VARCHAR(100) NOT NULL UNIQUE,
        productcode VARCHAR(50) NOT NULL UNIQUE,
        productline VARCHAR(100) NOT NULL,
        priceeach DECIMAL(15,2) NOT NULL,
        msrp DECIMAL(15,2) NOT NULL,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL
    );

    -- Create dim_dates table
    CREATE TABLE IF NOT EXISTS bl_dm.dim_dates (
        date_src_id VARCHAR(100) PRIMARY KEY,
        day_id INTEGER NOT NULL,
        month_id INTEGER NOT NULL,
        year_id INTEGER NOT NULL,
        qrt_id INTEGER NOT NULL,
        week_id INTEGER NOT NULL
    );

    -- Create fct_orders table
    CREATE TABLE IF NOT EXISTS bl_dm.fct_orders (
        ordernumber_src_id VARCHAR(100) PRIMARY KEY,
        payment_method_surr_id BIGINT NOT NULL,
        dealsize_surr_id BIGINT NOT NULL,
        product_surr_id BIGINT NOT NULL,
        customer_surr_id BIGINT NOT NULL,
        date_src_id VARCHAR(100) NOT NULL,
        sales DECIMAL(15,2) NOT NULL,
        quantityordered INTEGER NOT NULL,
        total_cost DECIMAL(15,2) NOT NULL,
        ta_insert_dt DATE NOT NULL,
        ta_update_dt DATE NOT NULL,
        event_dt DATE NOT NULL,
        source_system VARCHAR(100) NOT NULL,
        source_entity VARCHAR(100) NOT NULL,
        FOREIGN KEY (payment_method_surr_id) REFERENCES bl_dm.dim_payment_methods(payment_method_surr_id),
        FOREIGN KEY (dealsize_surr_id) REFERENCES bl_dm.dim_dealsizes(dealsize_surr_id),
        FOREIGN KEY (product_surr_id) REFERENCES bl_dm.dim_products(product_surr_id),
        FOREIGN KEY (customer_surr_id) REFERENCES bl_dm.dim_customers_scd(customer_surr_id),
        FOREIGN KEY (date_src_id) REFERENCES bl_dm.dim_dates(date_src_id)
    );

    RAISE NOTICE 'Tables created successfully';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred during table creation: %', SQLERRM;
END;
$$;




CREATE OR REPLACE PROCEDURE bl_dm.insert_default_values_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    -- Insert default row into dim_dealsizes
    INSERT INTO bl_dm.dim_dealsizes (
        dealsize_surr_id, dealsize_src_id, dealsize, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_dealsizes WHERE dealsize_surr_id = -1);

    -- Insert default row into dim_payment_methods
    INSERT INTO bl_dm.dim_payment_methods (
        payment_method_surr_id, payment_method_src_id, payment_method, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_payment_methods WHERE payment_method_surr_id = -1);

    -- Insert default row into dim_customers
    INSERT INTO bl_dm.dim_customers_scd (
        customer_surr_id, customer_src_id, customername, contactfirstname, contactlastname, phone, addressline1, city_id, city, state_id, state, country_id, country, start_dt, end_dt, is_active, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', 'n. a.', 'n. a.', 'n. a.', 'n. a.', -1, 'n. a.', -1, 'n. a.', -1, 'n. a.', '1900-01-01', '9999-12-31', 'Y', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_customers_scd WHERE customer_surr_id = -1);

    -- Insert default row into dim_products
    INSERT INTO bl_dm.dim_products (
        product_surr_id, product_src_id, productcode, productline, priceeach, msrp, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT -1, 'n. a.', 'n. a.', 'n. a.', -1, -1, '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_products WHERE product_surr_id = -1);

    -- Insert default row into dim_dates
    INSERT INTO bl_dm.dim_dates (
        date_src_id, day_id, month_id, year_id, qrt_id, week_id
    )
    SELECT 'n. a.', -1, -1, -1, -1, -1
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.dim_dates WHERE date_src_id = 'n. a.');

    -- Insert default row into fct_orders
    INSERT INTO bl_dm.fct_orders (
        ordernumber_src_id, payment_method_surr_id, dealsize_surr_id, product_surr_id, customer_surr_id, date_src_id, sales, quantityordered, total_cost, ta_insert_dt, ta_update_dt, event_dt, source_system, source_entity
    )
    SELECT 'n. a.', -1, -1, -1, -1, 'n. a.', -1, 1, -1, '1900-01-01', '1900-01-01', '1900-01-01', 'n. a.', 'n. a.'
    WHERE NOT EXISTS (SELECT 1 FROM bl_dm.fct_orders WHERE ordernumber_src_id = 'n. a.');

    RAISE NOTICE 'Default values inserted successfully';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred during default value insertion: %', SQLERRM;
END;
$$;



CALL bl_dm.create_dim_and_fct_tables_procedure();
CALL bl_dm.insert_default_values_procedure();


-----------------------------------------------------------------------------------------------------
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_dealsize_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_payment_method_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_product_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_country_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_state_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_city_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_address_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_customer_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_order_id_seq;


-- here i check index if they exist and making sure they do exsit

CREATE OR REPLACE PROCEDURE BL_DM.load_dm_dealsizes()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_DEALSIZES
    INSERT INTO BL_DM.DIM_DEALSIZES (
        DEALSIZE_SURR_ID, DEALSIZE, DEALSIZE_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT DISTINCT
        ds.dealsize_id AS dealsize_surr_id,
        ds.dealsize,
        ds.dealsize_src_id,
        ds.ta_insert_dt,
        ds.ta_update_dt,
        ds.source_system,
        ds.source_entity
    FROM BL_3NF.CE_DEALSIZES ds
    WHERE ds.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_DM.fct_orders)
    AND NOT EXISTS (
        SELECT 1 FROM BL_DM.DIM_DEALSIZES dds
        WHERE dds.dealsize_surr_id = ds.dealsize_id
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_dealsizes', rows_affected, 'Dealsizes loaded successfully into DM');
END;
$$;


-- payment methods ---------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_payment_methods()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_PAYMENT_METHODS
    INSERT INTO BL_DM.DIM_PAYMENT_METHODS (
        PAYMENT_METHOD_SURR_ID, PAYMENT_METHOD, PAYMENT_METHOD_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT DISTINCT
        pm.payment_method_id AS payment_method_surr_id,
        pm.payment_method,
        pm.payment_src_id, 
        pm.ta_insert_dt,
        pm.ta_update_dt,
        pm.source_system,
        pm.source_entity
    FROM BL_3NF.CE_PAYMENT_METHODS pm
    WHERE pm.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_DM.DIM_PAYMENT_METHODS)
    AND NOT EXISTS (
        SELECT 1 FROM BL_DM.DIM_PAYMENT_METHODS dpm
        WHERE dpm.payment_method_surr_id = pm.payment_method_id
    );

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_payment_methods', rows_affected, 'Payment methods loaded successfully into DM');
END;
$$;


   

-- Procedure to load data into DIM_DATES----------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_dates()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_DATES
    INSERT INTO BL_DM.dim_dates (
        date_id, day_id, month_id, year_id, qrt_id, week_id
    )
    SELECT DISTINCT
        TO_CHAR(event_dt::DATE, 'YYYYMMDD')::BIGINT AS date_id,  -- Using YYYYMMDD format as date_id
        EXTRACT(DAY FROM event_dt::DATE) AS day_id,
        EXTRACT(MONTH FROM event_dt::DATE) AS month_id,
        EXTRACT(YEAR FROM event_dt::DATE) AS year_id,
        EXTRACT(QUARTER FROM event_dt::DATE) AS qrt_id,
        EXTRACT(WEEK FROM event_dt::DATE) AS week_id
    FROM (
        SELECT event_dt FROM BL_3NF.CE_ORDERS
       
    ) AS events
    WHERE NOT EXISTS (
        SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = TO_CHAR(events.event_dt::DATE, 'YYYYMMDD')::BIGINT
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_dates', rows_affected, 'Dates loaded successfully into DIM_DATES');
END;
$$;




-- Procedure to load data into DIM_PRODUCTS-------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_products()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_PRODUCTS
    INSERT INTO BL_DM.DIM_PRODUCTS (
        product_surr_id, product_src_id, productcode, productline, priceeach, msrp, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT DISTINCT
        p.product_id AS product_surr_id,
        p.product_src_id,
        p.productcode,
        p.productline,
        p.priceeach,
        p.msrp,
        p.ta_insert_dt,
        CURRENT_TIMESTAMP AS ta_update_dt,
        p.source_system,
        p.source_entity
    FROM BL_3NF.CE_PRODUCTS p
    WHERE p.ta_insert_dt >= (
        SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) 
        FROM BL_DM.DIM_PRODUCTS
    )
    AND NOT EXISTS (
        SELECT 1 FROM BL_DM.DIM_PRODUCTS d
        WHERE d.product_surr_id = p.product_id
          AND d.product_src_id = p.product_src_id
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_products', rows_affected, 'Products loaded successfully into DIM_PRODUCTS');
END;
$$;




-- customers -------------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE bl_dm.load_dm_customers()
LANGUAGE plpgsql
AS $$
DECLARE
    rec RECORD;
    v_existing_customer RECORD;
BEGIN
    -- Ensure the sequence is aligned with the highest customer_surr_id
    PERFORM setval('bl_dm.customer_surr_id_seq', (SELECT COALESCE(MAX(customer_surr_id), 0) FROM bl_dm.dim_customers_scd) + 1, false);

    FOR rec IN
        SELECT DISTINCT
            c.customer_src_id,
            c.customername,
            c.contactfirstname,
            c.contactlastname,
            c.phone,
            a.addressline1,
            COALESCE(ct.city_id, -1) AS city_id,
            COALESCE(ct.city_name, 'n. a.') AS city,
            COALESCE(st.state_id, -1) AS state_id,
            COALESCE(st.state_name, 'n. a.') AS state,
            COALESCE(co.country_id, -1) AS country_id,
            COALESCE(co.country_name, 'n. a.') AS country,
            c.source_system,
            c.source_entity
        FROM BL_3NF.CE_CUSTOMERS_SCD c
        LEFT JOIN BL_3NF.CE_ADDRESSES a ON c.address_id = a.address_id
        LEFT JOIN BL_3NF.CE_CITIES ct ON a.city_id = ct.city_id
        LEFT JOIN BL_3NF.CE_STATES st ON ct.state_id = st.state_id
        LEFT JOIN BL_3NF.CE_COUNTRIES co ON st.country_id = co.country_id
        WHERE c.customer_src_id <> '-1'
    LOOP
        -- Check if the customer exists
        SELECT * INTO v_existing_customer
        FROM bl_dm.dim_customers_scd
        WHERE customer_src_id = rec.customer_src_id
          AND source_system = rec.source_system
          AND source_entity = rec.source_entity;

        IF FOUND THEN
            -- Update the existing record to mark it as inactive and set end date
            UPDATE bl_dm.dim_customers_scd
            SET 
                end_dt = CURRENT_DATE,
                is_active = 'N',
                ta_update_dt = CURRENT_TIMESTAMP
            WHERE customer_src_id = rec.customer_src_id
              AND source_system = rec.source_system
              AND source_entity = rec.source_entity
              AND is_active = 'Y'; -- Only update active records
        END IF;

        -- Insert the new record as active
        INSERT INTO bl_dm.dim_customers_scd (
            customer_surr_id, customer_src_id, customername, contactfirstname, contactlastname, 
            phone, addressline1, city_id, city, state_id, state, country_id, country,
            start_dt, end_dt, is_active, ta_insert_dt, ta_update_dt, 
            source_system, source_entity
        )
        VALUES (
            nextval('bl_dm.customer_surr_id_seq'), rec.customer_src_id, rec.customername, 
            rec.contactfirstname, rec.contactlastname, rec.phone, rec.addressline1, 
            rec.city_id, rec.city, rec.state_id, rec.state, rec.country_id, rec.country, 
            CURRENT_DATE, '9999-12-31'::DATE, 'Y', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 
            rec.source_system, rec.source_entity
        );
    END LOOP;
END;
$$;


-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders (
    ordernumber BIGINT,
    payment_method_surr_id INT,
    dealsize_surr_id INT,
    product_surr_id INT,
    customer_surr_id INT,
    date_id BIGINT,
    sales NUMERIC,
    quantityordered INT,
    total_cost NUMERIC,
    ta_insert_dt TIMESTAMP,
    ta_update_dt TIMESTAMP,
    event_dt DATE,
    source_system TEXT,
    source_entity TEXT,
    CONSTRAINT pk_fct_orders PRIMARY KEY (ordernumber, event_dt),
    CONSTRAINT fk_payment_method FOREIGN KEY (payment_method_surr_id) REFERENCES BL_DM.dim_payment_methods(payment_method_surr_id),
    CONSTRAINT fk_dealsize FOREIGN KEY (dealsize_surr_id) REFERENCES BL_DM.dim_dealsizes(dealsize_surr_id),
    CONSTRAINT fk_product FOREIGN KEY (product_surr_id) REFERENCES BL_DM.dim_products(product_surr_id),
    CONSTRAINT fk_customer FOREIGN KEY (customer_surr_id) REFERENCES BL_DM.dim_customers(customer_surr_id),
    CONSTRAINT fk_date FOREIGN KEY (date_id) REFERENCES BL_DM.dim_dates(date_id)
) PARTITION BY RANGE (event_dt);

-- Drop any existing partitions that might be conflicting
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_10;
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_11;
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_12;

-- Recreate the partitions with non-overlapping ranges
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_10 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-10-01') TO ('2005-11-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_11 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-11-01') TO ('2005-12-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_12 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-12-01') TO ('2006-01-01');
   
   
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_up_to_2024_05 PARTITION OF BL_DM.fct_orders
FOR VALUES FROM ('1900-01-01') TO ('2005-09-30');






   
 CREATE TABLE IF NOT EXISTS bl_cl.operation_log (
    log_id SERIAL PRIMARY KEY,
    log_type CHAR(1),
    procedure_name TEXT,
    table_name TEXT,
    rows_affected INT,
    execution_time NUMERIC,
    message TEXT,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
  
   
   
CREATE OR REPLACE PROCEDURE BL_DM.manage_fct_orders_partitions()
LANGUAGE plpgsql
AS $$
DECLARE
    partition_name text := FORMAT('fct_orders_%s', TO_CHAR(date_trunc('month', current_date), 'YYYY_MM'));
    old_partition_name TEXT := FORMAT('fct_orders_%s', TO_CHAR(date_trunc('month', current_date) - INTERVAL '3 month', 'YYYY_MM'));
    partition_start_date date := date_trunc('month', current_date);
    partition_end_date date := partition_start_date + INTERVAL '1 month';
    rows_affected int;
    start_time timestamp;
    end_time timestamp;
    execution_time numeric;
    message varchar(500);
   
BEGIN
    start_time := CLOCK_TIMESTAMP();

    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        
        EXECUTE FORMAT('SELECT COUNT(*) FROM bl_dm.%I', old_partition_name) INTO rows_affected;
    
        EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS bl_dm.%I PARTITION OF bl_dm.fct_orders FOR VALUES FROM (%L) TO (%L);',
                        partition_name, partition_start_date, partition_end_date);                 
        
        EXECUTE FORMAT('ALTER TABLE bl_dm.fct_orders DETACH PARTITION bl_dm.%I', 
                        old_partition_name); 
                       
        EXECUTE FORMAT('INSERT INTO bl_dm.fct_orders_archived
                        SELECT * FROM bl_dm.%I',
                        old_partition_name);
                       
        EXECUTE FORMAT('DROP TABLE bl_dm.%I', 
                        old_partition_name);
        
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);
        message := FORMAT('Created new partition bl_dm.%s, archived partition bl_dm.%I', 
                           partition_name, old_partition_name);
        
        -- Log the operation
        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('P', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', rows_affected, execution_time, message);
       
    ELSE 
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);

        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('N', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', 0, execution_time, 'Current partition already exists.');
    END IF;
     
EXCEPTION
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS
        message = MESSAGE_TEXT;
        
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);
        
        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('E', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', 0, execution_time, message);
        
        RAISE NOTICE 'Error occurred: %', message;
END;
$$;


call BL_DM.manage_fct_orders_partitions()





-- order

CREATE OR REPLACE PROCEDURE BL_DM.load_dm_orders()
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO BL_DM.fct_orders (
        ordernumber, 
        payment_method_surr_id, 
        dealsize_surr_id, 
        product_surr_id, 
        customer_surr_id, 
        date_id, 
        sales, 
        quantityordered, 
        total_cost, 
        ta_insert_dt, 
        ta_update_dt, 
        event_dt, 
        source_system, 
        source_entity
    )
    SELECT DISTINCT
       o.ordernumber::BIGINT AS ordernumber,
        o.payment_method_id AS payment_method_surr_id,
        o.dealsize_id AS dealsize_surr_id,
        o.product_id AS product_surr_id,
        o.customer_id AS customer_surr_id,
        COALESCE(TO_CHAR(o.event_dt, 'DDMMYYYY')::INT8, -1) AS date_id,
        o.sales,
        o.quantityordered,
        (o.sales * o.quantityordered) AS total_cost,
        o.ta_insert_dt,
        CURRENT_TIMESTAMP AS ta_update_dt,
        o.event_dt,
        o.source_system,
        o.source_entity
    FROM BL_3NF.CE_ORDERS o
    WHERE o.ta_insert_dt >= (SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) FROM BL_DM.fct_orders)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = COALESCE(TO_CHAR(o.event_dt, 'DDMMYYYY')::INT8, -1))
    AND EXISTS (SELECT 1 FROM BL_DM.dim_customers c WHERE c.customer_surr_id = o.customer_id)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_payment_methods pm WHERE pm.payment_method_surr_id = o.payment_method_id)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_dealsizes ds WHERE ds.dealsize_surr_id = o.dealsize_id)
    AND EXISTS (SELECT 1 FROM BL_DM.dim_products p WHERE p.product_surr_id = o.product_id)
    ON CONFLICT (ordernumber, event_dt)
    DO UPDATE SET
        payment_method_surr_id = EXCLUDED.payment_method_surr_id,
        dealsize_surr_id = EXCLUDED.dealsize_surr_id,
        product_surr_id = EXCLUDED.product_surr_id,
        customer_surr_id = EXCLUDED.customer_surr_id,
        date_id = EXCLUDED.date_id,
        sales = EXCLUDED.sales,
        quantityordered = EXCLUDED.quantityordered,
        total_cost = EXCLUDED.total_cost,
        ta_update_dt = CURRENT_TIMESTAMP,
        source_system = EXCLUDED.source_system,
        source_entity = EXCLUDED.source_entity;
    
    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_orders', 0, 'Orders loaded/updated successfully into DM');
EXCEPTION
    WHEN OTHERS THEN
        PERFORM BL_3NF.log_procedure_action('load_dm_orders', 0, 'Error during order load: ' || SQLERRM);
        RAISE;
END;
$$;





-- Execute the procedures
CALL BL_DM.load_dm_dealsizes();
CALL BL_DM.load_dm_payment_methods();
CALL BL_DM.load_dm_customers();
CALL BL_DM.load_dm_products();
CALL BL_DM.load_dm_dates();
CALL BL_DM.load_dm_orders();


-- Verify data in DM tables
SELECT * FROM BL_DM.DIM_DEALSIZES ;
SELECT * FROM BL_DM.DIM_PAYMENT_METHODS;
select * from bl_dm.dim_customers dcs ;
SELECT * FROM BL_DM.DIM_PRODUCTS LIMIT 10;
SELECT * FROM BL_DM.DIM_DATES LIMIT 10;

-- Verify data in the fact table
SELECT * FROM BL_DM.FCT_ORDERS LIMIT 10;









