-----------------------------------------------------------------------------------------------------
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_dealsize_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_payment_method_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_product_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_country_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_state_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_city_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_address_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_customer_id_seq;
CREATE SEQUENCE IF NOT EXISTS BL_DM.dm_order_id_seq;


-- here i check index if they exist and making sure they do exsit

CREATE OR REPLACE PROCEDURE BL_cl.load_dm_dealsizes()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_DEALSIZES
    INSERT INTO BL_DM.DIM_DEALSIZES (
        DEALSIZE_SURR_ID, DEALSIZE, DEALSIZE_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT distinct
        nextval('BL_DM.dm_dealsize_id_seq') AS dealsize_surr_id,  -- Auto-increment using sequence
        ds.dealsize,
        MIN(ds.dealsize_id::varchar) AS dealsize_src_id, 
        MIN(ds.ta_insert_dt) AS ta_insert_dt,
        current_date as source_system,
       'BL_3NF' as source_entity,
       'CE_DEALSIZES'
    FROM BL_3NF.CE_DEALSIZES ds
    WHERE ds.ta_insert_dt >= (
        -- Select the most recent ta_insert_dt from fct_orders
        SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) 
        FROM BL_DM.fct_orders
    )
    AND NOT EXISTS (
        -- Check if this record already exists in DIM_DEALSIZES
        SELECT 1 
        FROM BL_DM.DIM_DEALSIZES dds
        WHERE dds.dealsize = ds.dealsize
    )
   GROUP BY ds.dealsize;

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_dealsizes', rows_affected, 'Dealsizes loaded successfully into DM');
END;
$$;

delete from bl_dm.dim_dealsizes ;
call BL_cl.load_dm_dealsizes();
select * from bl_dm.dim_dealsizes ;

-- payment methods ---------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_cl.load_dm_payment_methods()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_PAYMENT_METHODS
    INSERT INTO BL_DM.DIM_PAYMENT_METHODS (
        PAYMENT_METHOD_SURR_ID, PAYMENT_METHOD, PAYMENT_METHOD_SRC_ID, TA_INSERT_DT, TA_UPDATE_DT, SOURCE_SYSTEM, SOURCE_ENTITY
    )
    SELECT DISTINCT
        nextval('BL_DM.dm_payment_method_id_seq') AS payment_method_surr_id,  -- Auto-increment using sequence
        pm.payment_method as payment_method,
        min(pm.payment_method_id::varchar) AS payment_method_src_id,  -- Convert payment_method_id from 3NF to varchar
        min(pm.ta_insert_dt) as ta_insert_dt ,
        current_date,
       'BL_3NF' as source_system,
       'CE_PAYMENT_METHODS' as source_entity
    FROM BL_3NF.CE_PAYMENT_METHODS pm
    WHERE pm.ta_insert_dt >= (
        -- Select the most recent ta_insert_dt from DIM_PAYMENT_METHODS
        SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) 
        FROM BL_DM.DIM_PAYMENT_METHODS
    )
    AND NOT EXISTS (
        -- Check if this record already exists in DIM_PAYMENT_METHODS
        SELECT 1 
        FROM BL_DM.DIM_PAYMENT_METHODS dpm
        WHERE dpm.payment_method= pm.payment_method::varchar
    )
   group by pm.payment_method;

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_payment_methods', rows_affected, 'Payment methods loaded successfully into DM');
END;
$$;


call BL_cl.load_dm_payment_methods();
select* from BL_DM.DIM_PAYMENT_METHODS;
   

-- Procedure to load data into DIM_DATES----------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_DM.load_dm_dates()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_DATES
    INSERT INTO BL_DM.dim_dates (
        date_id, day_id, month_id, year_id, qrt_id, week_id
    )
    SELECT DISTINCT
        TO_CHAR(event_dt::DATE, 'YYYYMMDD')::BIGINT AS date_id,  -- Using YYYYMMDD format as date_id
        EXTRACT(DAY FROM event_dt::DATE) AS day_id,
        EXTRACT(MONTH FROM event_dt::DATE) AS month_id,
        EXTRACT(YEAR FROM event_dt::DATE) AS year_id,
        EXTRACT(QUARTER FROM event_dt::DATE) AS qrt_id,
        EXTRACT(WEEK FROM event_dt::DATE) AS week_id
    FROM (
        SELECT event_dt FROM BL_3NF.CE_ORDERS
       
    ) AS events
    WHERE NOT EXISTS (
        SELECT 1 FROM BL_DM.dim_dates d WHERE d.date_id = TO_CHAR(events.event_dt::DATE, 'YYYYMMDD')::BIGINT
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_dates', rows_affected, 'Dates loaded successfully into DIM_DATES');
END;
$$;

call BL_DM.load_dm_dates();

select * from bl_dm.dim_dates dd 

-- Procedure to load data into DIM_PRODUCTS-------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_CL.load_dm_products()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert new records into DIM_PRODUCTS
    INSERT INTO BL_DM.DIM_PRODUCTS (
        product_surr_id, product_src_id, productcode, productline, priceeach, msrp, ta_insert_dt, ta_update_dt, source_system, source_entity
    )
    SELECT DISTINCT
        nextval('BL_DM.dm_product_id_seq') AS product_surr_id,  -- Auto-increment using sequence
        p.product_id::varchar AS product_src_id,  -- Use product_id from 3NF as the source ID and convert to varchar
        p.productcode,
        p.productline,
        p.priceeach,
        p.msrp,
        p.ta_insert_dt,
        CURRENT_TIMESTAMP AS ta_update_dt,
        'BL_3NF' as source_system,
        'CE_PRODUCTS' as source_entity
    FROM BL_3NF.CE_PRODUCTS p
    WHERE p.ta_insert_dt >= (
        -- Select the most recent ta_insert_dt from DIM_PRODUCTS
        SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) 
        FROM BL_DM.DIM_PRODUCTS
    )
    AND NOT EXISTS (
        -- Check if this record already exists in DIM_PRODUCTS
        SELECT 1 FROM BL_DM.DIM_PRODUCTS d
        WHERE d.product_src_id = p.product_id::varchar  -- Match by source ID
        AND d.source_system = 'BL_3NF'
        AND d.source_entity = 'CE_PRODUCTS' 
    );

    -- Get the number of rows affected by the insert operation
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- Log the action
    PERFORM BL_3NF.log_procedure_action('load_dm_products', rows_affected, 'Products loaded successfully into DIM_PRODUCTS');
END;
$$;

call BL_CL.load_dm_products();
select * from BL_DM.DIM_PRODUCTS ;

-- customers -------------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE BL_CL.load_dm_customers()
LANGUAGE plpgsql
AS $$
DECLARE
    rec RECORD;
    v_existing_customer RECORD;
BEGIN
    -- Ensure the sequence is aligned with the highest customer_surr_id
    PERFORM setval('bl_dm.customer_surr_id_seq', (SELECT COALESCE(MAX(customer_surr_id), 0) FROM bl_dm.dim_customers_scd) + 1, false);

    FOR rec IN
        SELECT DISTINCT
            c.customer_id,
            c.customername,
            c.contactfirstname,
            c.contactlastname,
            c.phone,
            COALESCE(a.addressline1, 'Unknown Address') AS addressline1,  -- Use a default value if addressline1 is NULL
            COALESCE(ct.city_id, -1) AS city_id,
            COALESCE(ct.city_name, 'n. a.') AS city,
            COALESCE(st.state_id, -1) AS state_id,
            COALESCE(st.state_name, 'n. a.') AS state,
            COALESCE(co.country_id, -1) AS country_id,
            COALESCE(co.country_name, 'n. a.') AS country,
            'BL_3NF' as source_system,
            'CE_CUSTOMERS_SCD' as source_entity
        FROM BL_3NF.CE_CUSTOMERS_SCD c
        LEFT JOIN BL_3NF.CE_ADDRESSES a 
            ON c.address_id = a.address_id 
            AND c.source_system = a.source_system 
            AND c.source_entity = a.source_entity
        LEFT JOIN BL_3NF.CE_CITIES ct 
            ON a.city_id = ct.city_id
            AND a.source_system = ct.source_system 
            AND a.source_entity = ct.source_entity
        LEFT JOIN BL_3NF.CE_STATES st 
            ON ct.state_id = st.state_id
            AND ct.source_system = st.source_system 
            AND ct.source_entity = st.source_entity
        LEFT JOIN BL_3NF.CE_COUNTRIES co 
            ON st.country_id = co.country_id
            AND st.source_system = co.source_system 
            AND st.source_entity = co.source_entity
            where c.is_active = 'Y'
            
    LOOP
        -- Check if the customer already exists in the DM layer
        SELECT * INTO v_existing_customer
        FROM bl_dm.dim_customers_scd
        WHERE customer_src_id = rec.customer_id::varchar(100)
          AND source_system =  'BL_3NF'
          AND source_entity =  'CE_CUSTOMERS_SCD';

        IF FOUND THEN
            -- Update the existing record to mark it as inactive and set the end date
            UPDATE bl_dm.dim_customers_scd
            SET 
                end_dt = CURRENT_DATE,
                is_active = 'N',
                ta_update_dt = CURRENT_TIMESTAMP
            WHERE customer_src_id = rec.customer_id::varchar(100)
              AND source_system = 'BL_3NF'
              AND source_entity =  'CE_CUSTOMERS_SCD'
              AND is_active = 'Y'; -- Only update active records
        END IF;

        -- Insert the new record as active
        INSERT INTO bl_dm.dim_customers_scd (
            customer_surr_id, customer_src_id, customername, contactfirstname, contactlastname, 
            phone, addressline1, city_id, city, state_id, state, country_id, country,
            start_dt, end_dt, is_active, ta_insert_dt, ta_update_dt, 
            source_system, source_entity
        )
        VALUES (
            nextval('bl_dm.customer_surr_id_seq'), rec.customer_id::varchar(100), rec.customername, 
            rec.contactfirstname, rec.contactlastname, rec.phone, rec.addressline1, 
            rec.city_id, rec.city, rec.state_id, rec.state, rec.country_id, rec.country, 
            CURRENT_DATE, '9999-12-31'::DATE, 'Y', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 
            'BL_3NF', 'CE_CUSTOMERS_SCD'
        );
    END LOOP;
END;
$$;



call bl_CL.load_dm_customers();
select * from bl_dm.dim_customers_scd;

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders (
    ordernumber BIGINT,
    payment_method_surr_id INT,
    dealsize_surr_id INT,
    product_surr_id INT,
    customer_surr_id INT,
    date_id BIGINT,
    sales NUMERIC,
    quantityordered INT,
    total_cost NUMERIC,
    ta_insert_dt TIMESTAMP,
    ta_update_dt TIMESTAMP,
    event_dt DATE,
    source_system TEXT,
    source_entity TEXT,
    unique (ordernumber, event_dt)
) PARTITION BY RANGE (event_dt);

-- Drop any existing partitions that might be conflicting
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_10;
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_11;
DROP TABLE IF EXISTS BL_DM.fct_orders_2005_12;

-- Recreate the partitions with non-overlapping ranges
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_10 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-10-01') TO ('2005-11-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_11 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-11-01') TO ('2005-12-01');

CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_2005_12 PARTITION OF BL_DM.fct_orders
    FOR VALUES FROM ('2005-12-01') TO ('2006-01-01');
   
   
CREATE TABLE IF NOT EXISTS BL_DM.fct_orders_up_to_2024_05 PARTITION OF BL_DM.fct_orders
FOR VALUES FROM ('1900-01-01') TO ('2005-09-30');






   
 CREATE TABLE IF NOT EXISTS bl_cl.operation_log (
    log_id SERIAL PRIMARY KEY,
    log_type CHAR(1),
    procedure_name TEXT,
    table_name TEXT,
    rows_affected INT,
    execution_time NUMERIC,
    message TEXT,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
  
   
   
CREATE OR REPLACE PROCEDURE BL_DM.manage_fct_orders_partitions()
LANGUAGE plpgsql
AS $$
DECLARE
    partition_name text := FORMAT('fct_orders_%s', TO_CHAR(date_trunc('month', current_date), 'YYYY_MM'));
    old_partition_name TEXT := FORMAT('fct_orders_%s', TO_CHAR(date_trunc('month', current_date) - INTERVAL '3 month', 'YYYY_MM'));
    partition_start_date date := date_trunc('month', current_date);
    partition_end_date date := partition_start_date + INTERVAL '1 month';
    rows_affected int;
    start_time timestamp;
    end_time timestamp;
    execution_time numeric;
    message varchar(500);
   
BEGIN
    start_time := CLOCK_TIMESTAMP();

    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        
        EXECUTE FORMAT('SELECT COUNT(*) FROM bl_dm.%I', old_partition_name) INTO rows_affected;
    
        EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS bl_dm.%I PARTITION OF bl_dm.fct_orders FOR VALUES FROM (%L) TO (%L);',
                        partition_name, partition_start_date, partition_end_date);                 
        
        EXECUTE FORMAT('ALTER TABLE bl_dm.fct_orders DETACH PARTITION bl_dm.%I', 
                        old_partition_name); 
                       
        EXECUTE FORMAT('INSERT INTO bl_dm.fct_orders_archived
                        SELECT * FROM bl_dm.%I',
                        old_partition_name);
                       
        EXECUTE FORMAT('DROP TABLE bl_dm.%I', 
                        old_partition_name);
        
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);
        message := FORMAT('Created new partition bl_dm.%s, archived partition bl_dm.%I', 
                           partition_name, old_partition_name);
        
        -- Log the operation
        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('P', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', rows_affected, execution_time, message);
       
    ELSE 
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);

        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('N', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', 0, execution_time, 'Current partition already exists.');
    END IF;
     
EXCEPTION
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS
        message = MESSAGE_TEXT;
        
        end_time := clock_timestamp();
        execution_time := EXTRACT(EPOCH FROM end_time - start_time);
        
        INSERT INTO bl_cl.operation_log (log_type, procedure_name, table_name, rows_affected, execution_time, message)
        VALUES ('E', 'manage_fct_orders_partitions', 'bl_dm.fct_orders', 0, execution_time, message);
        
        RAISE NOTICE 'Error occurred: %', message;
END;
$$;


call BL_DM.manage_fct_orders_partitions()



CREATE INDEX idx_orders_ta_insert_dt ON BL_3NF.CE_ORDERS(ta_insert_dt);
CREATE INDEX idx_orders_event_dt ON BL_3NF.CE_ORDERS(event_dt);
CREATE INDEX idx_dim_payment_methods ON BL_DM.dim_payment_methods(payment_method_src_id, source_system, source_entity);
CREATE INDEX idx_dim_dealsizes ON BL_DM.dim_dealsizes(dealsize_src_id, source_system, source_entity);
CREATE INDEX idx_dim_products ON BL_DM.dim_products(product_src_id, source_system, source_entity);
CREATE INDEX idx_dim_customers ON BL_DM.dim_customers(customer_src_id, source_system, source_entity);


-- order

CREATE OR REPLACE PROCEDURE BL_CL.load_dm_orders()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_affected INT := 0;
BEGIN
    -- Insert or update records in the fct_orders table
    INSERT INTO BL_DM.fct_orders (
        ordernumber, 
        payment_method_surr_id, 
        dealsize_surr_id, 
        product_surr_id, 
        customer_surr_id, 
        date_id, 
        sales, 
        quantityordered, 
        total_cost, 
        ta_insert_dt, 
        ta_update_dt, 
        event_dt, 
        source_system, 
        source_entity
    )
    SELECT 
        o.ordernumber::BIGINT AS ordernumber,
        pm_surr.payment_method_surr_id,
        ds_surr.dealsize_surr_id,
        p_surr.product_surr_id,
        c_surr.customer_surr_id,
        COALESCE(TO_CHAR(o.event_dt, 'DDMMYYYY')::INT8, -1) AS date_id,
        o.sales,
        o.quantityordered,
        (o.sales * o.quantityordered) AS total_cost,
        o.ta_insert_dt,
        CURRENT_TIMESTAMP AS ta_update_dt,
        o.event_dt,
        'BL_3NF' as source_system,
        'CE_ORDERS' as source_entity
    FROM BL_3NF.CE_ORDERS o
    INNER JOIN BL_DM.dim_payment_methods pm_surr 
        ON pm_surr.payment_method_src_id = o.payment_method_id::VARCHAR
        AND pm_surr.source_system =  'BL_3NF'
        AND pm_surr.source_entity = 'CE_PAYMENT_METHODS'
    INNER JOIN BL_DM.dim_dealsizes ds_surr 
        ON ds_surr.dealsize_src_id = o.dealsize_id::VARCHAR
        AND ds_surr.source_system =  'BL_3NF'
        AND ds_surr.source_entity = 'CE_DEALSIZES'
    INNER JOIN BL_DM.dim_products p_surr 
        ON p_surr.product_src_id = o.product_id::VARCHAR
        AND p_surr.source_system =  'BL_3NF'
        AND p_surr.source_entity = 'CE_PRODUCTS'
    INNER JOIN BL_DM.dim_customers_scd  c_surr 
        ON c_surr.customer_src_id = o.customer_id::VARCHAR
        AND c_surr.source_system =  'BL_3NF'
        AND c_surr.source_entity = 'CE_CUSTOMERS_SCD'
    WHERE o.ta_insert_dt >= (
        SELECT COALESCE(MAX(ta_insert_dt), '1900-01-01'::timestamp) 
        FROM BL_DM.fct_orders
    );

   

    -- Log the action
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    PERFORM BL_3NF.log_procedure_action('load_dm_orders', rows_affected, 'Orders loaded/updated successfully into DM');
EXCEPTION
    WHEN OTHERS THEN
        PERFORM BL_3NF.log_procedure_action('load_dm_orders', 0, 'Error during order load: ' || SQLERRM);
        RAISE;
END;
$$;



call BL_CL.load_dm_orders();
select * from BL_DM.fct_orders;


